substitutions:
  device_friendly_name: "X light switch"
  device_name: "x-light-switch"
  device_make: "Sonoff"
  device_model: "Switchman M5 (1-Gang)"
  package_version: "3.0.0"

  button_a_gpio: GPIO00           # Button A
  relay_a_gpio: GPIO23            # Relay A
  led_indicator_gpio: GPIO19      # LED Indicator (Red LED)
  led_status_gpio: GPIO05         # Status LED (Blue LED)
  led_pwm_output_gpio: GPIO18     # LED PWM output

  log_level: INFO
  timezone: "Europe/Tallinn"

  # Button timing configurations
  filter_delay_on: 50ms
  filter_delay_off: 50ms

  # Single Click timings (if needed)
  timing_click_1: ON for at most 500ms
  timing_click_2: OFF for at least 100ms
  
  # Double Click Timings
  timing_double_click_1: ON for at most 500ms
  timing_double_click_2: OFF for at most 400ms
  timing_double_click_3: ON for at most 500ms
  timing_double_click_4: OFF for at least 250ms

  # Button Hold Timings
  timing_hold: ON for at least 1s
  timing_hold_repeat: 500ms

  # Pulse Timing
  timing_pulse: 250ms

esp32:
  board: esp32dev
  framework:
    type: arduino
    version: recommended

esphome:
  name: "${device_name}"
  friendly_name: "${device_friendly_name}"
  comment: "${device_model} by ${device_make} version ${package_version}"
  project:
    name: "${device_make}.${device_model}"
    version: "${package_version}"
  on_boot:
    - priority: 900.0
      then:
        - lambda: |-
            id(cpu_speed) = ESP.getCpuFreqMHz();

logger:
  level: "${log_level}"
  baud_rate: 0

globals:
  - id: cpu_speed
    type: int
    restore_value: no
    initial_value: "0"

wifi:
  fast_connect: false
  power_save_mode: none
  ssid: "${wifi_ssid}"
  password: "${wifi_password}"
  
  ap:
    ssid: "${device_name}"
    password: "${ap_password}"

time:
  - platform: sntp
    id: time_service
    timezone: ${timezone}

captive_portal:

web_server:
  port: 80

api:
  # encryption:
  #   key: "${api_key}"

ota:
  safe_mode: true
  password: "${ota_password}"

text_sensor:
  - platform: wifi_info
    ip_address:
      id: ip_address
      name: "IP Address"
      icon: "mdi:wan"

sensor:
  - platform: uptime
    name: "Uptime"
    id: sensor_uptime
    update_interval: 60s
    entity_category: "diagnostic"
    internal: true

  - platform: internal_temperature
    name: "Internal Temperature"
    icon: mdi:thermometer
    disabled_by_default: true

  - platform: wifi_signal
    name: "Wi-Fi Signal Strength"
    update_interval: 60s
    entity_category: "diagnostic"

  - platform: template
    name: "CPU Frequency"
    lambda: |-
      return id(cpu_speed);
    unit_of_measurement: MHz
    entity_category: diagnostic

button:
  - platform: restart
    name: "Reboot Device"
    entity_category: diagnostic

switch:
  - platform: gpio
    name: "Relay A"
    id: relay_a
    pin: ${relay_a_gpio}
    restore_mode: RESTORE_DEFAULT_OFF
    on_turn_on:
      - switch.turn_on: led_indicator
    on_turn_off:
      - switch.turn_off: led_indicator

  - platform: gpio
    name: "LED Indicator"
    id: led_indicator
    pin: ${led_indicator_gpio}
    restore_mode: RESTORE_DEFAULT_OFF

select:
  - platform: template
    name: "Mode - Button A"
    id: mode_a
    options:
      - "Latching"    # Mode 0
      - "Momentary"   # Mode 1
      - "Pulse"       # Mode 2
      - "Decoupled"   # Mode 3
    initial_option: "Latching"
    restore_value: true

output:
  - platform: ledc
    id: pwm_output
    pin: ${led_pwm_output_gpio}
    frequency: 1000 Hz

light:
  - platform: monochromatic
    output: pwm_output
    name: "Red LED"
    restore_mode: RESTORE_DEFAULT_OFF

  - platform: status_led
    name: "Blue LED"
    id: led_status
    pin:
      number: ${led_status_gpio}
      inverted: true

binary_sensor:
  - platform: status
    name: "API Status"

  - platform: gpio
    name: "Button A"
    id: button_a
    pin:
      number: ${button_a_gpio}
      mode: INPUT_PULLUP
      inverted: true
    filters:
      - delayed_on: ${filter_delay_on}
      - delayed_off: ${filter_delay_off}

    on_press:
      # Latching Mode (Mode 0)
      - if:
          condition:
            lambda: 'return id(mode_a).active_index() == 0;'
          then:
            - if:
                condition:
                  lambda: 'return WiFi.isConnected() || global_api_server->is_connected();'
                then:
                  - switch.toggle: relay_a
                  - if:
                      condition:
                        lambda: 'return global_api_server->is_connected();'
                      then:
                        - homeassistant.event:
                            event: esphome.switchman_m5
                            data:
                              button: A
                              action: switch_toggle
                else:
                  - switch.toggle: relay_a

      # Momentary Mode (Mode 1)
      - if:
          condition:
            lambda: 'return id(mode_a).active_index() == 1;'
          then:
            - switch.turn_on: relay_a
            - delay: ${timing_pulse}
            - switch.turn_off: relay_a

      # Pulse Mode (Mode 2)
      - if:
          condition:
            lambda: 'return id(mode_a).active_index() == 2;'
          then:
            - switch.turn_on: relay_a
            - delay: ${timing_pulse}
            - switch.turn_off: relay_a

      # Decoupled Mode (Mode 3)
      - if:
          condition:
            lambda: 'return id(mode_a).active_index() == 3;'
          then:
            - if:
                condition:
                  lambda: 'return WiFi.isConnected() || global_api_server->is_connected();'
                then:
                  - switch.toggle: relay_a
                  - if:
                      condition:
                        lambda: 'return global_api_server->is_connected();'
                      then:
                        - homeassistant.event:
                            event: esphome.switchman_m5
                            data:
                              button: A
                              action: decoupled_toggle
                else:
                  - switch.toggle: relay_a

    on_multi_click:
      # Double Click Action
      - timing:
          - ${timing_double_click_1}
          - ${timing_double_click_2}
          - ${timing_double_click_3}
          - ${timing_double_click_4}
        then:
          - if:
              condition:
                lambda: 'return WiFi.isConnected() || global_api_server->is_connected();'
              then:
                - homeassistant.event:
                    event: esphome.switchman_m5
                    data:
                      button: A
                      action: double_click
              else:
                - switch.toggle: relay_a

      # Hold Action
      - timing:
          - ${timing_hold}
        then:
          - while:
              condition:
                binary_sensor.is_on: button_a
              then:
                - light.toggle: led_status
                - delay: ${timing_hold_repeat}
          - if:
              condition:
                lambda: 'return WiFi.isConnected() || global_api_server->is_connected();'
              then:
                - homeassistant.event:
                    event: esphome.switchman_m5
                    data:
                      button: A
                      action: hold
              else:
                - switch.toggle: relay_a
