substitutions:
  device_friendly_name: "Switchman M5 1G"
  device_name: "switchman-m5-1g"
  device_make: "Sonoff"
  device_model: "Switchman M5 (1-Gang)"
  package_version: "3.0.0"
  api_key: !secret api_key
  wifi_ssid: !secret wifi_ssid
  wifi_password: !secret wifi_password
  ota_password: !secret ota_password
  button_a_gpio: GPIO00
  relay_a_gpio: GPIO23
  red_led_gpio: GPIO19
  blue_led_gpio: GPIO05
  hold_start_ms: 200ms
  debounce_ms: 100ms
  button_a_on_service: ""
  button_a_on_entity: ""
  button_a_off_service: ""
  button_a_off_entity: ""
  button_a_hold_service: ""
  button_a_hold_entity: ""
  default_mode_a: "Coupled"
  default_relay_a_target_mode: "Off"

  ap_password: !secret ap_password

esphome:
  name: "${device_name}"
  friendly_name: "${device_friendly_name}"
  comment: "${device_model} by ${device_make} version ${package_version}"
  on_boot:
    - priority: 900.0
      then:
        - lambda: |-
            id(cpu_speed) = ESP.getCpuFreqMHz();

esp32:
  board: esp32dev
  framework:
    type: arduino
    version: recommended

logger:
  baud_rate: 0

wifi:
  ssid: ${wifi_ssid}
  password: ${wifi_password}

ota:
  platform: esphome
  password: ${ota_password}

api:
  encryption:
    key: ${api_key}

web_server:
  port: 80

globals:
  - id: a_hold_triggered
    type: bool
    restore_value: false
    initial_value: 'false'
  - id: button_a_busy
    type: bool
    restore_value: false
    initial_value: 'false'
  - id: cpu_speed
    type: int
    restore_value: false
    initial_value: "0"

sensor:
  - platform: uptime
    name: "Uptime (s)"
    id: sensor_uptime
    update_interval: 60s
    entity_category: "diagnostic"
    internal: true
    on_raw_value:
      then:
        - text_sensor.template.publish:
            id: uptime_human
            state: !lambda |-
              int seconds = round(id(sensor_uptime).raw_state);
              int days = seconds / (24 * 3600);
              seconds %= 24 * 3600;
              int hours = seconds / 3600;
              seconds %= 3600;
              int minutes = seconds / 60;
              seconds %= 60;
              return (
                (days ? String(days) + "d " : "") +
                (hours ? String(hours) + "h " : "") +
                (minutes ? String(minutes) + "m " : "") +
                (String(seconds) + "s")
              ).c_str();

  - platform: template
    id: esp_memory
    icon: mdi:memory
    name: Free Memory
    lambda: return heap_caps_get_free_size(MALLOC_CAP_INTERNAL) / 1024;
    unit_of_measurement: "kB"
    state_class: measurement
    entity_category: "diagnostic"
    disabled_by_default: true

  - platform: internal_temperature
    name: "Internal Temperature"
    icon: mdi:heat-wave
    disabled_by_default: true

  - platform: template
    name: "CPU Frequency"
    icon: "mdi:speedometer"
    accuracy_decimals: 0
    unit_of_measurement: MHz
    disabled_by_default: true
    lambda: |-
      return (id(cpu_speed));
    entity_category: diagnostic

  - platform: wifi_signal
    name: "RSSI"
    id: sensor_rssi
    update_interval: 60s
    entity_category: "diagnostic"

text_sensor:
  - platform: wifi_info
    ip_address:
      id: ip_address
      name: "IP Address"
      icon: "mdi:wan"

  - platform: template
    name: "Uptime"
    id: uptime_human
    icon: "mdi:timer-check-outline"
    update_interval: 60s
    entity_category: "diagnostic"
    disabled_by_default: true


switch:
  - platform: gpio
    name: "Red LED"
    id: red_led
    internal: true
    pin: ${red_led_gpio}

  - platform: gpio
    name: "Relay A"
    id: relay_a
    pin: ${relay_a_gpio}
    restore_mode: RESTORE_DEFAULT_OFF

  - platform: template
    name: "Button A state"
    id: button_a_state
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    on_turn_on:
      - if:
          condition:
            lambda: 'return id(button_a_busy);'
          then:
            - switch.toggle: button_a_state
      - lambda: 'id(button_a_busy) = true;'
      - switch.turn_on: red_led
      - script.execute: a_on_action
      - if:
          condition:
            lambda: 'return id(mode_a).state == std::string("Coupled") && id(relay_a).state == false;'
          then:
            - switch.turn_on: relay_a
      - delay: ${debounce_ms}
      - lambda: 'id(button_a_busy) = false;'
    on_turn_off:
      - if:
          condition:
            lambda: 'return id(button_a_busy);'
          then:
            - switch.toggle: button_a_state
      - lambda: 'id(button_a_busy) = true;'
      - switch.turn_off: red_led
      - script.execute: a_off_action
      - if:
          condition:
            lambda: 'return id(mode_a).state == std::string("Coupled") && id(relay_a).state == true;'
          then:
            - switch.turn_off: relay_a
      - delay: ${debounce_ms}
      - lambda: 'id(button_a_busy) = false;'


light:
  - platform: status_led
    name: "Blue LED"
    id: blue_led
    internal: true
    pin:
      number: ${blue_led_gpio}
      inverted: true
      ignore_strapping_warning: true
    restore_mode: RESTORE_DEFAULT_OFF

select:
  - platform: template
    id: mode_a
    name: "Button A mode"
    options:
      - "Coupled"
      - "Decoupled"
    optimistic: true
    restore_value: true
    initial_option: ${default_mode_a}
    entity_category: config

  - platform: template
    id: relay_a_target_mode
    name: "Relay A target mode"
    options:
      - "On"
      - "Off"
    optimistic: true
    restore_value: true
    initial_option: ${default_relay_a_target_mode}
    entity_category: config
    on_value:
      then:
        - if:
            condition:
              lambda: 'return id(relay_a_target_mode).state == std::string("On");'
            then:
              - switch.turn_on: relay_a
            else:
              - switch.turn_off: relay_a

button:
  - platform: restart
    name: "Reboot Device"
    id: button_restart
    icon: mdi:power-cycle
    entity_category: "diagnostic"

  - platform: template
    name: "Button A hold action"
    id: button_a_sim_hold
    on_press:
      - script.execute: a_hold_action

binary_sensor:
  - platform: gpio
    id: button_a
    pin:
      number: ${button_a_gpio}
      mode: INPUT_PULLUP
      inverted: true
      ignore_strapping_warning: true
    on_press:
      - lambda: 'id(a_hold_triggered) = false;'
      - script.execute: a_hold_check
    on_release:
      - if:
          condition:
            lambda: 'return !id(a_hold_triggered);'
          then:
            - switch.toggle: button_a_state

script:
  - id: a_hold_blink
    mode: restart
    then:
      - while:
          condition:
            binary_sensor.is_on: button_a
          then:
            - light.turn_on: blue_led
            - delay: 100ms
            - light.turn_off: blue_led
            - delay: 100ms
      - light.turn_off: blue_led

  - id: a_hold_check
    then:
      - delay: ${hold_start_ms}
      - if:
          condition:
            binary_sensor.is_on: button_a
          then:
            - lambda: 'id(a_hold_triggered) = true;'
            - script.execute: a_hold_blink
            - button.press: button_a_sim_hold

  - id: a_on_action
    then:
      - if:
          condition:
            lambda: 'return std::string("${button_a_on_service}") != "" && std::string("${button_a_on_entity}") != "";'
          then:
            - homeassistant.service:
                service: "${button_a_on_service}"
                data:
                  entity_id: "${button_a_on_entity}"

  - id: a_off_action
    then:
      - if:
          condition:
            lambda: 'return std::string("${button_a_off_service}") != "" && std::string("${button_a_off_entity}") != "";'
          then:
            - homeassistant.service:
                service: "${button_a_off_service}"
                data:
                  entity_id: "${button_a_off_entity}"

  - id: a_hold_action
    then:
      - if:
          condition:
            lambda: 'return std::string("${button_a_hold_service}") != "" && std::string("${button_a_hold_entity}") != "";'
          then:
            - homeassistant.service:
                service: "${button_a_hold_service}"
                data:
                  entity_id: "${button_a_hold_entity}"

