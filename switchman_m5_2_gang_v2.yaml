substitutions:
  # Device identity (adjust to your setup)
  device_friendly_name: ""
  device_name: ""
  device_ip: ""
  device_make: "Sonoff"
  device_model: "Switchman M5 (2-Gang)"
  package_version: "3.0.0"

  api_key: !secret api_key
  wifi_ssid: !secret wifi_ssid
  wifi_password: !secret wifi_password
  ota_password: !secret ota_password
  ap_password: !secret ap_password

  # Hardware pins (Sonoff Switchman M5 2-Gang defaults)
  button_a_gpio: GPIO04           # Button A
  button_b_gpio: GPIO15           # Button B
  relay_a_gpio: GPIO23            # Relay A (LED A tied here)
  relay_b_gpio: GPIO19            # Relay B
  led_indicator_gpio: GPIO22      # Red LED B
  led_status_gpio: GPIO05         # Blue LED
  led_pwm_output_gpio: GPIO18     # LED PWM output (backlight)

  # Runtime & logging
  log_level: INFO
  timezone: "Europe/Tallinn"

  # Button timings
  filter_delay_on: 50ms
  filter_delay_off: 50ms

  # Single click timings (mutually exclusive gestures)
  timing_click_1: ON for at most 500ms
  timing_click_2: OFF for at least 100ms

  # Double click timings
  timing_double_click_1: ON for at most 500ms
  timing_double_click_2: OFF for at most 400ms
  timing_double_click_3: ON for at most 500ms
  timing_double_click_4: OFF for at least 250ms

  # Hold timings
  timing_hold: ON for at least 1s
  timing_hold_repeat: 500ms

  # Behavior selections
  default_mode_a: "Coupled"         # Coupled | Decoupled
  default_mode_b: "Coupled"         # Coupled | Decoupled
  momentary_duration: 200ms         # Fixed for "Momentary 200ms"

  # Failover (Decoupled -> Coupled when HA offline)
  failover_default: "1"             # 1 = enabled, 0 = disabled

  # HA service wiring — CHANNEL A (leave empty to do nothing)
  button_a_on_service: ""           # e.g. "switch.turn_on"
  button_a_on_entity: ""            # e.g. "switch.some_switch"
  button_a_off_service: ""
  button_a_off_entity: ""
  button_a_double_service: ""
  button_a_double_entity: ""
  button_a_hold_service: ""
  button_a_hold_entity: ""

  # HA service wiring — CHANNEL B
  button_b_on_service: ""
  button_b_on_entity: ""
  button_b_off_service: ""
  button_b_off_entity: ""
  button_b_double_service: ""
  button_b_double_entity: ""
  button_b_hold_service: ""
  button_b_hold_entity: ""

esphome:
  name: "${device_name}"
  friendly_name: "${device_friendly_name}"
  comment: "${device_model} by ${device_make} version ${package_version}"
  name_add_mac_suffix: false
  on_boot:
    - priority: 900.0
      then:
        - lambda: |-
            id(cpu_speed) = ESP.getCpuFreqMHz();
    - priority: 600.0
      then:
        # Sync relays to button states at boot when Coupled (avoids mismatch after reboot)
        - if:
            condition:
              lambda: 'return id(mode_a).state == std::string("Coupled");'
            then:
              - if:
                  condition:
                    lambda: 'return id(button_a_state).state != id(relay_a).state;'
                  then:
                    - if:
                        condition:
                          lambda: 'return id(button_a_state).state;'
                        then:
                          - switch.turn_on: relay_a
                        else:
                          - switch.turn_off: relay_a
        - if:
            condition:
              lambda: 'return id(mode_b).state == std::string("Coupled");'
            then:
              - if:
                  condition:
                    lambda: 'return id(button_b_state).state != id(relay_b).state;'
                  then:
                    - if:
                        condition:
                          lambda: 'return id(button_b_state).state;'
                        then:
                          - switch.turn_on: relay_b
                        else:
                          - switch.turn_off: relay_b

esp32:
  board: esp32dev
  framework:
    type: arduino
    version: recommended

logger:
  level: "${log_level}"
  baud_rate: 0

wifi:
  fast_connect: false
  power_save_mode: none
  ssid: ${wifi_ssid}
  password: ${wifi_password}
  ap:
    ssid: ${device_name}
    password: ${ap_password}

ota:
  - platform: esphome
    password: ${ota_password}

api:
  # encryption:
  #   key: "${api_key}"

web_server:
  port: 80

time:
  - platform: sntp
    id: time_service
    timezone: ${timezone}

captive_portal:

globals:
  - id: cpu_speed
    type: int
    restore_value: no
    initial_value: "0"

  # Persisted flag for failover (1/0)
  - id: failover_flag
    type: int
    restore_value: yes
    initial_value: ${failover_default}

# ---------------------------
# Sensors / Text sensors
# ---------------------------
text_sensor:
  - platform: wifi_info
    ip_address:
      id: ip_address
      name: "IP Address"
      icon: "mdi:wan"

  - platform: template
    name: "Uptime"
    id: uptime_human
    icon: "mdi:timer-check-outline"
    update_interval: 60s
    entity_category: "diagnostic"
    disabled_by_default: true

sensor:
  - platform: uptime
    name: "Uptime (s)"
    id: sensor_uptime
    update_interval: 60s
    entity_category: "diagnostic"
    internal: true
    on_raw_value:
      then:
        - text_sensor.template.publish:
            id: uptime_human
            state: !lambda |-
              int seconds = round(id(sensor_uptime).raw_state);
              int days = seconds / (24 * 3600);
              seconds = seconds % (24 * 3600);
              int hours = seconds / 3600;
              seconds = seconds % 3600;
              int minutes = seconds / 60;
              seconds = seconds % 60;
              return (
                (days ? String(days) + "d " : "") +
                (hours ? String(hours) + "h " : "") +
                (minutes ? String(minutes) + "m " : "") +
                (String(seconds) + "s")
              ).c_str();

  - platform: template
    id: esp_memory
    icon: mdi:memory
    name: Free Memory
    lambda: return heap_caps_get_free_size(MALLOC_CAP_INTERNAL) / 1024;
    unit_of_measurement: "kB"
    state_class: measurement
    entity_category: "diagnostic"
    disabled_by_default: true

  - platform: internal_temperature
    name: "Internal Temperature"
    icon: mdi:heat-wave
    disabled_by_default: true

  - platform: template
    name: "CPU Frequency"
    icon: "mdi:speedometer"
    accuracy_decimals: 0
    unit_of_measurement: MHz
    disabled_by_default: true
    lambda: |-
      return (id(cpu_speed));
    entity_category: diagnostic

  - platform: wifi_signal
    name: "RSSI"
    id: sensor_rssi
    update_interval: 60s
    entity_category: "diagnostic"

# ---------------------------
# Buttons (utility + virtual)
# ---------------------------
button:
  - platform: restart
    name: "Reboot Device"
    id: button_restart
    icon: mdi:power-cycle
    entity_category: "diagnostic"

  # Virtual buttons to simulate gestures from HA (Channel A)
  - platform: template
    name: "Button A double click action"
    id: button_a_sim_double
    on_press:
      - script.execute: a_double_press

  - platform: template
    name: "Button A hold action"
    id: button_a_sim_hold
    on_press:
      - script.execute: a_hold_press

  # Virtual buttons to simulate gestures from HA (Channel B)
  - platform: template
    name: "Button B double click action"
    id: button_b_sim_double
    on_press:
      - script.execute: b_double_press

  - platform: template
    name: "Button B hold action"
    id: button_b_sim_hold
    on_press:
      - script.execute: b_hold_press

# ---------------------------
# Outputs / Lights (LEDs)
# ---------------------------
output:
  - platform: ledc
    id: pwm_output
    pin: ${led_pwm_output_gpio}
    frequency: 1000 Hz

light:
  # HIDDEN from HA UI, still used internally for backlight control
  - platform: monochromatic
    output: pwm_output
    name: "Red LED"
    id: red_led_backlight
    internal: true
    restore_mode: RESTORE_DEFAULT_OFF
    icon: 'mdi:led-outline'
    entity_category: 'config'

  # HIDDEN from HA UI, used for connection/hold feedback (same as 1-gang)
  - platform: status_led
    name: "Blue LED"
    id: led_status
    internal: true
    pin:
      number: ${led_status_gpio}
      inverted: true
      ignore_strapping_warning: true
    restore_mode: RESTORE_DEFAULT_ON

# ---------------------------
# Switches (relays + B red indicator + failover toggle)
# ---------------------------
switch:
  # Red indicator (channel B), hidden from HA
  - platform: gpio
    name: "LED indicator"
    id: led_indicator
    internal: true
    pin: ${led_indicator_gpio}

  # Relay A
  - platform: gpio
    name: "Relay A"
    id: relay_a
    pin: ${relay_a_gpio}
    restore_mode: RESTORE_DEFAULT_OFF
    on_turn_on:
      - script.execute: a_on_action
      # Mirror to Button A state in Coupled
      - if:
          condition:
            lambda: 'return id(mode_a).state == std::string("Coupled") && id(button_a_state).state == false;'
          then:
            - switch.turn_on: button_a_state
      # Auto-off if Inching
      - if:
          condition:
            lambda: 'return id(behavior_a).state == std::string("Inching");'
          then:
            - script.execute: inching_a_off
    on_turn_off:
      - script.execute: a_off_action
      # Mirror to Button A state in Coupled
      - if:
          condition:
            lambda: 'return id(mode_a).state == std::string("Coupled") && id(button_a_state).state == true;'
          then:
            - switch.turn_off: button_a_state

  # Relay B
  - platform: gpio
    name: "Relay B"
    id: relay_b
    pin: ${relay_b_gpio}
    restore_mode: RESTORE_DEFAULT_OFF
    on_turn_on:
      - switch.turn_on: led_indicator
      - script.execute: b_on_action
      # Mirror to Button B state in Coupled
      - if:
          condition:
            lambda: 'return id(mode_b).state == std::string("Coupled") && id(button_b_state).state == false;'
          then:
            - switch.turn_on: button_b_state
      # Auto-off if Inching
      - if:
          condition:
            lambda: 'return id(behavior_b).state == std::string("Inching");'
          then:
            - script.execute: inching_b_off
    on_turn_off:
      - switch.turn_off: led_indicator
      - script.execute: b_off_action
      # Mirror to Button B state in Coupled
      - if:
          condition:
            lambda: 'return id(mode_b).state == std::string("Coupled") && id(button_b_state).state == true;'
          then:
            - switch.turn_off: button_b_state

  # Button A state (virtual)
  - platform: template
    name: "Button A state"
    id: button_a_state
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    on_turn_on:
      # Only call HA action when DECOUPLED, to avoid duplicates in Coupled
      - if:
          condition:
            lambda: 'return id(mode_a).state == std::string("Decoupled");'
          then:
            - script.execute: a_on_action
      # Mirror to Relay A in Coupled
      - if:
          condition:
            lambda: 'return id(mode_a).state == std::string("Coupled") && id(relay_a).state == false;'
          then:
            - switch.turn_on: relay_a
    on_turn_off:
      # Only call HA action when DECOUPLED, to avoid duplicates in Coupled
      - if:
          condition:
            lambda: 'return id(mode_a).state == std::string("Decoupled");'
          then:
            - script.execute: a_off_action
      # Mirror to Relay A in Coupled
      - if:
          condition:
            lambda: 'return id(mode_a).state == std::string("Coupled") && id(relay_a).state == true;'
          then:
            - switch.turn_off: relay_a

  # Button B state (virtual)
  - platform: template
    name: "Button B state"
    id: button_b_state
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    on_turn_on:
      - switch.turn_on: led_indicator
      # Only call HA action when DECOUPLED
      - if:
          condition:
            lambda: 'return id(mode_b).state == std::string("Decoupled");'
          then:
            - script.execute: b_on_action
      # Mirror to Relay B in Coupled
      - if:
          condition:
            lambda: 'return id(mode_b).state == std::string("Coupled") && id(relay_b).state == false;'
          then:
            - switch.turn_on: relay_b
    on_turn_off:
      - switch.turn_off: led_indicator
      # Only call HA action when DECOUPLED
      - if:
          condition:
            lambda: 'return id(mode_b).state == std::string("Decoupled");'
          then:
            - script.execute: b_off_action
      # Mirror to Relay B in Coupled
      - if:
          condition:
            lambda: 'return id(mode_b).state == std::string("Coupled") && id(relay_b).state == true;'
          then:
            - switch.turn_off: relay_b

  # Failover (Decoupled → Coupled when HA offline) – global
  - platform: template
    name: "Failover"
    id: failover_decoupled_switch
    entity_category: config
    lambda: 'return id(failover_flag) == 1;'
    turn_on_action:
      - lambda: 'id(failover_flag) = 1;'
    turn_off_action:
      - lambda: 'id(failover_flag) = 0;'

# ---------------------------
# Selects (Modes & Behaviors)
# ---------------------------
select:
  - platform: template
    id: mode_a
    name: "Button A mode"
    options: [Coupled, Decoupled]
    optimistic: true
    restore_value: true
    initial_option: ${default_mode_a}
    entity_category: config

  - platform: template
    id: behavior_a
    name: "Relay A behavior"
    options: ["Latching", "Momentary 200ms", "Inching"]
    optimistic: true
    restore_value: true
    initial_option: "Latching"
    entity_category: config

  - platform: template
    id: mode_b
    name: "Button B mode"
    options: [Coupled, Decoupled]
    optimistic: true
    restore_value: true
    initial_option: ${default_mode_b}
    entity_category: config

  - platform: template
    id: behavior_b
    name: "Relay B behavior"
    options: ["Latching", "Momentary 200ms", "Inching"]
    optimistic: true
    restore_value: true
    initial_option: "Latching"
    entity_category: config

# ---------------------------
# Numbers (Inching seconds)
# ---------------------------
number:
  - platform: template
    id: inching_a_secs
    name: "Inching A (s)"
    min_value: 1
    max_value: 600
    step: 1
    initial_value: 5
    optimistic: true
    restore_value: true
    entity_category: config

  - platform: template
    id: inching_b_secs
    name: "Inching B (s)"
    min_value: 1
    max_value: 600
    step: 1
    initial_value: 5
    optimistic: true
    restore_value: true
    entity_category: config

# ---------------------------
# Binary sensors (buttons & status)
# ---------------------------
binary_sensor:
  # Make the status LED blink when not connected/trying to connect (same as 1-gang)
  - platform: template
    name: "API connected"
    id: sensor_api_connected
    internal: true
    entity_category: 'diagnostic'
    device_class: 'connectivity'
    lambda: return global_api_server->is_connected();
    on_press:
      - light.turn_off: led_status     # connected -> blue OFF
    on_release:
      - light.turn_on: led_status      # offline -> blue ON (status_led still blinks on boot/connecting)

  - platform: status
    name: "API Status"
    id: sensor_status
    disabled_by_default: true

  # Physical Button A (internal only)
  - platform: gpio
    id: button_a
    internal: true
    pin:
      number: ${button_a_gpio}
      mode: INPUT_PULLUP
      inverted: true
      ignore_strapping_warning: true
    filters:
      - delayed_on: ${filter_delay_on}
      - delayed_off: ${filter_delay_off}
    on_multi_click:
      # Double click
      - timing:
          - ${timing_double_click_1}
          - ${timing_double_click_2}
          - ${timing_double_click_3}
          - ${timing_double_click_4}
        then:
          - button.press: button_a_sim_double
          - script.execute: a_double_press
      # Hold (repeat)
      - timing:
          - ${timing_hold}
        then:
          - while:
              condition:
                binary_sensor.is_on: button_a
              then:
                - light.toggle: led_status
                - button.press: button_a_sim_hold
                - script.execute: a_hold_press
                - delay: ${timing_hold_repeat}
          - light.turn_off: led_status
      # Single click
      - timing:
          - ${timing_click_1}
          - ${timing_click_2}
        then:
          - script.execute: a_single_press

  # Physical Button B (internal only)
  - platform: gpio
    id: button_b
    internal: true
    pin:
      number: ${button_b_gpio}
      mode: INPUT_PULLUP
      inverted: true
      ignore_strapping_warning: true
    filters:
      - delayed_on: ${filter_delay_on}
      - delayed_off: ${filter_delay_off}
    on_multi_click:
      # Double click
      - timing:
          - ${timing_double_click_1}
          - ${timing_double_click_2}
          - ${timing_double_click_3}
          - ${timing_double_click_4}
        then:
          - button.press: button_b_sim_double
          - script.execute: b_double_press
      # Hold (repeat)
      - timing:
          - ${timing_hold}
        then:
          - while:
              condition:
                binary_sensor.is_on: button_b
              then:
                - light.toggle: led_status
                - button.press: button_b_sim_hold
                - script.execute: b_hold_press
                - delay: ${timing_hold_repeat}
          - light.turn_off: led_status
      # Single click
      - timing:
          - ${timing_click_1}
          - ${timing_click_2}
        then:
          - script.execute: b_single_press

# ---------------------------
# Action scripts (per channel)
# ---------------------------
script:
  # ---- Channel A: gestures -> behavior ----
  - id: a_single_press
    then:
      - if:
          condition:
            lambda: |-
              const bool coupled = (id(mode_a).state == std::string("Coupled"));
              const bool decoupled_failover =
                  (id(mode_a).state == std::string("Decoupled"))
                  && (id(failover_flag) == 1)
                  && (!global_api_server->is_connected());
              return coupled || decoupled_failover;
          then:
            - if:
                condition:
                  lambda: 'return id(behavior_a).state == std::string("Latching");'
                then:
                  - switch.toggle: relay_a
            - if:
                condition:
                  lambda: 'return id(behavior_a).state == std::string("Momentary 200ms");'
                then:
                  - switch.turn_on: relay_a
                  - delay: ${momentary_duration}
                  - switch.turn_off: relay_a
            - if:
                condition:
                  lambda: 'return id(behavior_a).state == std::string("Inching");'
                then:
                  - switch.turn_on: relay_a
          else:
            - switch.toggle: button_a_state

  - id: a_double_press
    then:
      - if:
          condition:
            lambda: 'return std::string("${button_a_double_service}") != "" && std::string("${button_a_double_entity}") != "";'
          then:
            - homeassistant.service:
                service: "${button_a_double_service}"
                data:
                  entity_id: "${button_a_double_entity}"

  - id: a_hold_press
    then:
      - if:
          condition:
            lambda: 'return std::string("${button_a_hold_service}") != "" && std::string("${button_a_hold_entity}") != "";'
          then:
            - homeassistant.service:
                service: "${button_a_hold_service}"
                data:
                  entity_id: "${button_a_hold_entity}"

  # A: inching auto-off
  - id: inching_a_off
    mode: restart
    then:
      - delay: !lambda |-
          return (uint32_t)(id(inching_a_secs).state * 1000.0f);
      - if:
          condition:
            switch.is_on: relay_a
          then:
            - switch.turn_off: relay_a

  # A: ON/OFF actions (called from relay in Coupled, from state in Decoupled)
  - id: a_on_action
    then:
      - if:
          condition:
            lambda: 'return std::string("${button_a_on_service}") != "" && std::string("${button_a_on_entity}") != "";'
          then:
            - homeassistant.service:
                service: "${button_a_on_service}"
                data:
                  entity_id: "${button_a_on_entity}"

  - id: a_off_action
    then:
      - if:
          condition:
            lambda: 'return std::string("${button_a_off_service}") != "" && std::string("${button_a_off_entity}") != "";'
          then:
            - homeassistant.service:
                service: "${button_a_off_service}"
                data:
                  entity_id: "${button_a_off_entity}"

  # ---- Channel B: gestures -> behavior ----
  - id: b_single_press
    then:
      - if:
          condition:
            lambda: |-
              const bool coupled = (id(mode_b).state == std::string("Coupled"));
              const bool decoupled_failover =
                  (id(mode_b).state == std::string("Decoupled"))
                  && (id(failover_flag) == 1)
                  && (!global_api_server->is_connected());
              return coupled || decoupled_failover;
          then:
            - if:
                condition:
                  lambda: 'return id(behavior_b).state == std::string("Latching");'
                then:
                  - switch.toggle: relay_b
            - if:
                condition:
                  lambda: 'return id(behavior_b).state == std::string("Momentary 200ms");'
                then:
                  - switch.turn_on: relay_b
                  - delay: ${momentary_duration}
                  - switch.turn_off: relay_b
            - if:
                condition:
                  lambda: 'return id(behavior_b).state == std::string("Inching");'
                then:
                  - switch.turn_on: relay_b
          else:
            - switch.toggle: button_b_state

  - id: b_double_press
    then:
      - if:
          condition:
            lambda: 'return std::string("${button_b_double_service}") != "" && std::string("${button_b_double_entity}") != "";'
          then:
            - homeassistant.service:
                service: "${button_b_double_service}"
                data:
                  entity_id: "${button_b_double_entity}"

  - id: b_hold_press
    then:
      - if:
          condition:
            lambda: 'return std::string("${button_b_hold_service}") != "" && std::string("${button_b_hold_entity}") != "";'
          then:
            - homeassistant.service:
                service: "${button_b_hold_service}"
                data:
                  entity_id: "${button_b_hold_entity}"

  # B: inching auto-off
  - id: inching_b_off
    mode: restart
    then:
      - delay: !lambda |-
          return (uint32_t)(id(inching_b_secs).state * 1000.0f);
      - if:
          condition:
            switch.is_on: relay_b
          then:
            - switch.turn_off: relay_b

  # B: ON/OFF actions
  - id: b_on_action
    then:
      - if:
          condition:
            lambda: 'return std::string("${button_b_on_service}") != "" && std::string("${button_b_on_entity}") != "";'
          then:
            - homeassistant.service:
                service: "${button_b_on_service}"
                data:
                  entity_id: "${button_b_on_entity}"

  - id: b_off_action
    then:
      - if:
          condition:
            lambda: 'return std::string("${button_b_off_service}") != "" && std::string("${button_b_off_entity}") != "";'
          then:
            - homeassistant.service:
                service: "${button_b_off_service}"
                data:
                  entity_id: "${button_b_off_entity}"
