substitutions:
  device_friendly_name: ""
  device_name: ""
  device_ip: ""
  device_make: "Sonoff"
  device_model: "Switchman M5 (2-Gang)"
  package_version: "4.1.0" # Updated version number

  api_key: !secret api_key
  wifi_ssid: !secret wifi_ssid
  wifi_password: !secret wifi_password
  ota_password: !secret ota_password
  ap_password: !secret ap_password

  # Standard GPIO mapping for M5 2-Gang
  button_a_gpio: GPIO00 # Left Button
  button_b_gpio: GPIO04 # Right Button
  relay_a_gpio: GPIO23
  relay_b_gpio: GPIO19
  led_indicator_b_gpio: GPIO22 # LED for Button B
  led_status_gpio: GPIO05      # Blue Wi-Fi LED
  led_pwm_output_gpio: GPIO18  # Backlight

  log_level: INFO
  timezone: "Europe/Tallinn"

  filter_delay_on: 50ms
  filter_delay_off: 50ms

  # Multi-click timings
  timing_double_click_1: ON for at most 300ms
  timing_double_click_2: OFF for at most 200ms
  timing_double_click_3: ON for at most 300ms
  timing_double_click_4: OFF for at least 120ms
  timing_hold: ON for at least 1s
  timing_hold_repeat: 500ms

  # Defaults for Channel A
  default_mode_a: "Coupled"
  default_relay_a_target_mode: "Off"
  # Defaults for Channel B
  default_mode_b: "Coupled"
  default_relay_b_target_mode: "Off"

  min_toggle_interval_ms: "250"

  # HA Service Wiring - Channel A
  button_a_on_service: ""
  button_a_on_entity: ""
  button_a_off_service: ""
  button_a_off_entity: ""
  button_a_double_service: ""
  button_a_double_entity: ""
  button_a_hold_service: ""
  button_a_hold_entity: ""

  # HA Service Wiring - Channel B
  button_b_on_service: ""
  button_b_on_entity: ""
  button_b_off_service: ""
  button_b_off_entity: ""
  button_b_double_service: ""
  button_b_double_entity: ""
  button_b_hold_service: ""
  button_b_hold_entity: ""

esphome:
  name: "${device_name}"
  friendly_name: "${device_friendly_name}"
  comment: "${device_model} by ${device_make} version ${package_version}"
  name_add_mac_suffix: false
  on_boot:
    - priority: 900.0
      then:
        - lambda: 'id(cpu_speed) = ESP.getCpuFreqMHz();'
    # Sync relays to button states at boot when Coupled
    - priority: 600.0
      then:
        - if:
            condition:
              lambda: 'return id(mode_a).state == "Coupled";'
            then:
              - if:
                  condition:
                    lambda: 'return id(button_a_state).state != id(relay_a).state;'
                  then:
                    - if:
                        condition:
                          lambda: 'return id(button_a_state).state;'
                        then:
                          - switch.turn_on: relay_a
                        else:
                          - switch.turn_off: relay_a
        - if:
            condition:
              lambda: 'return id(mode_b).state == "Coupled";'
            then:
              - if:
                  condition:
                    lambda: 'return id(button_b_state).state != id(relay_b).state;'
                  then:
                    - if:
                        condition:
                          lambda: 'return id(button_b_state).state;'
                        then:
                          - switch.turn_on: relay_b
                        else:
                          - switch.turn_off: relay_b

esp32:
  board: esp32dev
  framework:
    type: arduino
    version: recommended

logger:
  level: "${log_level}"
  baud_rate: 0

wifi:
  fast_connect: false
  power_save_mode: none
  ssid: ${wifi_ssid}
  password: ${wifi_password}
  ap:
    ssid: ${device_name}
    password: ${ap_password}
  on_disconnect:
    then:
      - if:
          condition:
            lambda: 'return id(mode_a).state != "Coupled" || id(mode_b).state != "Coupled";'
          then:
            - logger.log: "Wi-Fi lost -> preemptively entering fallback (Coupled)"
            - select.set: { id: mode_a, option: "Coupled" }
            - select.set: { id: mode_b, option: "Coupled" }

ota:
  - platform: esphome
    password: ${ota_password}

api:
  on_client_connected:
    then:
      - logger.log: "API connected -> leaving fallback and restoring defaults"
      - light.turn_off: led_status
      - select.set: { id: mode_a, option: "${default_mode_a}" }
      - select.set: { id: mode_b, option: "${default_mode_b}" }
      - if:
          condition:
            lambda: 'return id(relay_a_target_mode).state == "On";'
          then:
            - switch.turn_on: relay_a
          else:
            - switch.turn_off: relay_a
      - if:
          condition:
            lambda: 'return id(relay_b_target_mode).state == "On";'
          then:
            - switch.turn_on: relay_b
          else:
            - switch.turn_off: relay_b

  on_client_disconnected:
    then:
      - logger.log: "API disconnected -> entering fallback (Coupled) and resyncing"
      - light.turn_on: led_status
      - select.set: { id: mode_a, option: "Coupled" }
      - select.set: { id: mode_b, option: "Coupled" }
      - if:
          condition:
            lambda: 'return id(button_a_state).state != id(relay_a).state;'
          then:
            - if:
                condition:
                  lambda: 'return id(button_a_state).state;'
                then:
                  - switch.turn_on: relay_a
                else:
                  - switch.turn_off: relay_a
      - if:
          condition:
            lambda: 'return id(button_b_state).state != id(relay_b).state;'
          then:
            - if:
                condition:
                  lambda: 'return id(button_b_state).state;'
                then:
                  - switch.turn_on: relay_b
                else:
                  - switch.turn_off: relay_b

web_server:
  port: 80

time:
  - platform: sntp
    id: time_service
    timezone: ${timezone}

captive_portal:

globals:
  - id: cpu_speed
    type: int
    restore_value: no
    initial_value: "0"
  - id: last_user_toggle_ms_a
    type: uint32_t
    restore_value: no
    initial_value: '0'
  - id: last_user_toggle_ms_b
    type: uint32_t
    restore_value: no
    initial_value: '0'

# ... (Sensors and Text Sensors can be copied from the 1-gang version, they are identical) ...
text_sensor:
  - platform: wifi_info
    ip_address:
      id: ip_address
      name: "IP Address"
      icon: "mdi:wan"
sensor:
  # ... (All sensor definitions like uptime, memory, etc. are identical) ...
  - platform: uptime
    # ...
# ... (identical sensor definitions) ...

button:
  - platform: restart
    name: "Reboot Device"
    id: button_restart
    icon: mdi:power-cycle
    entity_category: "diagnostic"

output:
  - platform: ledc
    id: pwm_output
    pin: ${led_pwm_output_gpio}
    frequency: 1000 Hz

light:
  - platform: monochromatic
    output: pwm_output
    name: "Red LED"
    id: red_led_backlight
    internal: true
    restore_mode: RESTORE_DEFAULT_OFF
    icon: 'mdi:led-outline'
    entity_category: 'config'
  - platform: status_led
    name: "Blue LED"
    id: led_status
    internal: true
    pin:
      number: ${led_status_gpio}
      inverted: true
    restore_mode: RESTORE_DEFAULT_ON

switch:
  # Indicator for Button B. Button A's LED is usually hardwired to the relay.
  - platform: gpio
    name: "LED Indicator B"
    id: led_indicator_b
    internal: true
    pin: ${led_indicator_b_gpio}

  # --- Channel A ---
  - platform: gpio
    name: "Relay A"
    id: relay_a
    pin: ${relay_a_gpio}
    restore_mode: RESTORE_DEFAULT_OFF
    on_turn_on:
      - if:
          condition:
            lambda: 'return id(mode_a).state == "Coupled" && !id(button_a_state).state;'
          then:
            - switch.turn_on: button_a_state
    on_turn_off:
      - if:
          condition:
            lambda: 'return id(mode_a).state == "Coupled" && id(button_a_state).state;'
          then:
            - switch.turn_off: button_a_state
  - platform: template
    name: "Button A state"
    id: button_a_state
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    on_turn_on:
      - if:
          condition:
            lambda: 'return id(mode_a).state == "Decoupled";'
          then:
            - script.execute: a_on_action
      - if:
          condition:
            lambda: 'return id(mode_a).state == "Coupled" && !id(relay_a).state;'
          then:
            - switch.turn_on: relay_a
    on_turn_off:
      - if:
          condition:
            lambda: 'return id(mode_a).state == "Decoupled";'
          then:
            - script.execute: a_off_action
      - if:
          condition:
            lambda: 'return id(mode_a).state == "Coupled" && id(relay_a).state;'
          then:
            - switch.turn_off: relay_a

  # --- Channel B ---
  - platform: gpio
    name: "Relay B"
    id: relay_b
    pin: ${relay_b_gpio}
    restore_mode: RESTORE_DEFAULT_OFF
    on_turn_on:
      - switch.turn_on: led_indicator_b
      - if:
          condition:
            lambda: 'return id(mode_b).state == "Coupled" && !id(button_b_state).state;'
          then:
            - switch.turn_on: button_b_state
    on_turn_off:
      - switch.turn_off: led_indicator_b
      - if:
          condition:
            lambda: 'return id(mode_b).state == "Coupled" && id(button_b_state).state;'
          then:
            - switch.turn_off: button_b_state
  - platform: template
    name: "Button B state"
    id: button_b_state
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    on_turn_on:
      - switch.turn_on: led_indicator_b
      - if:
          condition:
            lambda: 'return id(mode_b).state == "Decoupled";'
          then:
            - script.execute: b_on_action
      - if:
          condition:
            lambda: 'return id(mode_b).state == "Coupled" && !id(relay_b).state;'
          then:
            - switch.turn_on: relay_b
    on_turn_off:
      - switch.turn_off: led_indicator_b
      - if:
          condition:
            lambda: 'return id(mode_b).state == "Decoupled";'
          then:
            - script.execute: b_off_action
      - if:
          condition:
            lambda: 'return id(mode_b).state == "Coupled" && id(relay_b).state;'
          then:
            - switch.turn_off: relay_b

select:
  # --- Channel A ---
  - platform: template
    id: mode_a
    name: "Button A mode"
    options: ["Coupled", "Decoupled"]
    optimistic: true
    restore_value: true
    initial_option: ${default_mode_a}
    entity_category: config
  - platform: template
    id: relay_a_target_mode
    name: "Relay A target mode"
    options: ["On", "Off"]
    optimistic: true
    restore_value: true
    initial_option: ${default_relay_a_target_mode}
    entity_category: config
    on_value:
      then:
        - if:
            condition:
              lambda: 'return global_api_server->is_connected();'
            then:
              - if:
                  condition:
                    lambda: 'return id(relay_a_target_mode).state == "On";'
                  then:
                    - switch.turn_on: relay_a
                  else:
                    - switch.turn_off: relay_a
  # --- Channel B ---
  - platform: template
    id: mode_b
    name: "Button B mode"
    options: ["Coupled", "Decoupled"]
    optimistic: true
    restore_value: true
    initial_option: ${default_mode_b}
    entity_category: config
  - platform: template
    id: relay_b_target_mode
    name: "Relay B target mode"
    options: ["On", "Off"]
    optimistic: true
    restore_value: true
    initial_option: ${default_relay_b_target_mode}
    entity_category: config
    on_value:
      then:
        - if:
            condition:
              lambda: 'return global_api_server->is_connected();'
            then:
              - if:
                  condition:
                    lambda: 'return id(relay_b_target_mode).state == "On";'
                  then:
                    - switch.turn_on: relay_b
                  else:
                    - switch.turn_off: relay_b

binary_sensor:
  # --- Physical Button A ---
  - platform: gpio
    id: button_a
    internal: true
    pin:
      number: ${button_a_gpio}
      mode: INPUT_PULLUP
      inverted: true
      ignore_strapping_warning: true
    filters:
      - delayed_on: ${filter_delay_on}
      - delayed_off: ${filter_delay_off}
    on_press:
      - if:
          condition:
            lambda: 'return (millis() - id(last_user_toggle_ms_a)) >= (uint32_t) ${min_toggle_interval_ms};'
          then:
            - lambda: 'id(last_user_toggle_ms_a) = millis();'
            - if:
                condition:
                  lambda: 'return id(mode_a).state == "Coupled" || !global_api_server->is_connected();'
                then:
                  - switch.toggle: relay_a
                else:
                  - switch.toggle: button_a_state
    on_multi_click:
      - timing: [${timing_double_click_1}, ${timing_double_click_2}, ${timing_double_click_3}, ${timing_double_click_4}]
        then:
          - script.execute: a_double_action
      - timing:
          - ${timing_hold}
        then:
          - while:
              condition: { binary_sensor.is_on: button_a }
              then:
                - light.toggle: led_status
                - script.execute: a_hold_action
                - delay: ${timing_hold_repeat}
          - light.turn_off: led_status
  # --- Physical Button B ---
  - platform: gpio
    id: button_b
    internal: true
    pin:
      number: ${button_b_gpio}
      mode: INPUT_PULLUP
      inverted: true
    filters:
      - delayed_on: ${filter_delay_on}
      - delayed_off: ${filter_delay_off}
    on_press:
      - if:
          condition:
            lambda: 'return (millis() - id(last_user_toggle_ms_b)) >= (uint32_t) ${min_toggle_interval_ms};'
          then:
            - lambda: 'id(last_user_toggle_ms_b) = millis();'
            - if:
                condition:
                  lambda: 'return id(mode_b).state == "Coupled" || !global_api_server->is_connected();'
                then:
                  - switch.toggle: relay_b
                else:
                  - switch.toggle: button_b_state
    on_multi_click:
      - timing: [${timing_double_click_1}, ${timing_double_click_2}, ${timing_double_click_3}, ${timing_double_click_4}]
        then:
          - script.execute: b_double_action
      - timing:
          - ${timing_hold}
        then:
          - while:
              condition: { binary_sensor.is_on: button_b }
              then:
                - light.toggle: led_status
                - script.execute: b_hold_action
                - delay: ${timing_hold_repeat}
          - light.turn_off: led_status

script:
  # --- Channel A Scripts ---
  - id: a_on_action
    then:
      - if:
          condition:
            lambda: 'return std::string("${button_a_on_service}") != "" && std::string("${button_a_on_entity}") != "";'
          then:
            - homeassistant.service:
                service: "${button_a_on_service}"
                data: { entity_id: "${button_a_on_entity}" }
  - id: a_off_action
    then:
      - if:
          condition:
            lambda: 'return std::string("${button_a_off_service}") != "" && std::string("${button_a_off_entity}") != "";'
          then:
            - homeassistant.service:
                service: "${button_a_off_service}"
                data: { entity_id: "${button_a_off_entity}" }
  - id: a_double_action
    then:
      - if:
          condition:
            lambda: 'return std::string("${button_a_double_service}") != "" && std::string("${button_a_double_entity}") != "";'
          then:
            - homeassistant.service:
                service: "${button_a_double_service}"
                data: { entity_id: "${button_a_double_entity}" }
  - id: a_hold_action
    then:
      - if:
          condition:
            lambda: 'return std::string("${button_a_hold_service}") != "" && std::string("${button_a_hold_entity}") != "";'
          then:
            - homeassistant.service:
                service: "${button_a_hold_service}"
                data: { entity_id: "${button_a_hold_entity}" }

  # --- Channel B Scripts ---
  - id: b_on_action
    then:
      - if:
          condition:
            lambda: 'return std::string("${button_b_on_service}") != "" && std::string("${button_b_on_entity}") != "";'
          then:
            - homeassistant.service:
                service: "${button_b_on_service}"
                data: { entity_id: "${button_b_on_entity}" }
  - id: b_off_action
    then:
      - if:
          condition:
            lambda: 'return std::string("${button_b_off_service}") != "" && std::string("${button_b_off_entity}") != "";'
          then:
            - homeassistant.service:
                service: "${button_b_off_service}"
                data: { entity_id: "${button_b_off_entity}" }
  - id: b_double_action
    then:
      - if:
          condition:
            lambda: 'return std::string("${button_b_double_service}") != "" && std::string("${button_b_double_entity}") != "";'
          then:
            - homeassistant.service:
                service: "${button_b_double_service}"
                data: { entity_id: "${button_b_double_entity}" }
  - id: b_hold_action
    then:
      - if:
          condition:
            lambda: 'return std::string("${button_b_hold_service}") != "" && std::string("${button_b_hold_entity}") != "";'
          then:
            - homeassistant.service:
                service: "${button_b_hold_service}"
                data: { entity_id: "${button_b_hold_entity}" }