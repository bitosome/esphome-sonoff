substitutions:
  device_friendly_name: "Switchman M5 2G"
  device_name: "switchman-m5-2g"
  device_make: "Sonoff"
  device_model: "Switchman M5 (2-Gang)"
  package_version: "4.0.1"

  wifi_ssid: !secret wifi_ssid
  wifi_password: !secret wifi_password
  ota_password: !secret ota_password
  ap_password: !secret ap_password

  button_a_gpio: GPIO04
  button_b_gpio: GPIO15
  relay_a_gpio: GPIO23
  relay_b_gpio: GPIO19
  red_led_gpio: GPIO22
  blue_led_gpio: GPIO05

  button_a_on_service: ""
  button_a_on_entity: ""

  button_a_off_service: ""
  button_a_off_entity: ""

  button_a_hold_service: ""
  button_a_hold_entity: ""

  default_mode_a: "Coupled"
  default_relay_a_target_mode: "Off"

  button_b_on_service: ""
  button_b_on_entity: ""

  button_b_off_service: ""
  button_b_off_entity: ""

  button_b_hold_service: ""
  button_b_hold_entity: ""

  default_mode_b: "Coupled"
  default_relay_b_target_mode: "Off"

  hold_start_ms: 500ms
  debounce_ms: 50ms

  # Walkthrough Master/Slave role configuration
  # Possible values: "master" or "slave"
  role: "master"
  # Simplified master reference for slaves
  # Example: master_entity_base: "wc_2_light_switch_2"
  master_entity_base: ""
  # Derived master entities used for forwarding and mirroring (can be overridden in minis if desired)
  master_button_a_entity: "switch.${master_entity_base}_button_a_state"
  master_button_b_entity: "switch.${master_entity_base}_button_b_state"
  master_button_a_hold_entity: "button.${master_entity_base}_button_a_hold_action"
  master_button_b_hold_entity: "button.${master_entity_base}_button_b_hold_action"

esphome:
  name: "${device_name}"
  friendly_name: "${device_friendly_name}"
  comment: "${device_model} by ${device_make} version ${package_version}"

esp32:
  board: esp32dev
  framework:
    type: arduino
    version: recommended

logger:
  level: WARN
  baud_rate: 0

preferences:
  flash_write_interval: 5min

wifi:
  ssid: ${wifi_ssid}
  password: ${wifi_password}
  power_save_mode: none

ota:
  platform: esphome
  password: ${ota_password}

api:

globals:
  - id: a_hold_triggered
    type: bool
    restore_value: false
    initial_value: "false"
  - id: b_hold_triggered
    type: bool
    restore_value: false
    initial_value: "false"
  - id: button_a_busy
    type: bool
    restore_value: false
    initial_value: "false"
  - id: button_b_busy
    type: bool
    restore_value: false
    initial_value: "false"
  - id: button_a_suppress
    type: bool
    restore_value: false
    initial_value: "false"
  - id: button_b_suppress
    type: bool
    restore_value: false
    initial_value: "false"
  - id: peer_a_on
    type: bool
    restore_value: false
    initial_value: "false"
  - id: peer_b_on
    type: bool
    restore_value: false
    initial_value: "false"

button:
  - platform: restart
    name: "Reboot Device"
    id: button_restart
    icon: mdi:power-cycle
    entity_category: "diagnostic"

  - platform: template
    name: "Button A hold action"
    id: button_a_sim_hold
    on_press:
      - script.execute: a_hold_action

  - platform: template
    name: "Button B hold action"
    id: button_b_sim_hold
    on_press:
      - script.execute: b_hold_action

light:
  - platform: status_led
    name: "Blue LED"
    id: blue_led
    internal: true
    pin:
      number: ${blue_led_gpio}
      inverted: true
      ignore_strapping_warning: true
    restore_mode: RESTORE_DEFAULT_OFF


switch:
  - platform: gpio
    name: "Red LED"
    id: red_led
    internal: true
    pin: ${red_led_gpio}

  - platform: gpio
    name: "Relay A"
    id: relay_a
    pin: ${relay_a_gpio}
    restore_mode: RESTORE_DEFAULT_OFF

  - platform: gpio
    name: "Relay B"
    id: relay_b
    pin: ${relay_b_gpio}
    restore_mode: RESTORE_DEFAULT_OFF

  - platform: template
    name: "Button A state"
    id: button_a_state
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    on_turn_on:
      - if:
          condition:
            lambda: "return id(button_a_busy);"
          then:
            - switch.toggle: button_a_state
      - lambda: "id(button_a_busy) = true;"
      # Update indicator based on local OR peer state
      - if:
          condition:
            lambda: 'return id(button_a_state).state || id(peer_a_on);'
          then:
            - light.turn_on: blue_led
          else:
            - light.turn_off: blue_led
      - if:
          condition:
            lambda: 'return !id(button_a_suppress);'
          then:
            - script.execute: a_on_action
            - if:
                condition:
                  lambda: 'return id(mode_a).state == std::string("Coupled") && id(relay_a).state == false;'
                then:
                  - switch.turn_on: relay_a
      - lambda: "id(button_a_busy) = false;"
    on_turn_off:
      - if:
          condition:
            lambda: "return id(button_a_busy);"
          then:
            - switch.toggle: button_a_state
      - lambda: "id(button_a_busy) = true;"
      # Update indicator based on local OR peer state
      - if:
          condition:
            lambda: 'return id(button_a_state).state || id(peer_a_on);'
          then:
            - light.turn_on: blue_led
          else:
            - light.turn_off: blue_led
      - if:
          condition:
            lambda: 'return !id(button_a_suppress);'
          then:
            - script.execute: a_off_action
            - if:
                condition:
                  lambda: 'return id(mode_a).state == std::string("Coupled") && id(relay_a).state == true;'
                then:
                  - switch.turn_off: relay_a
      - lambda: "id(button_a_busy) = false;"

  - platform: template
    name: "Button B state"
    id: button_b_state
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    on_turn_on:
      - if:
          condition:
            lambda: "return id(button_b_busy);"
          then:
            - switch.toggle: button_b_state
      - lambda: "id(button_b_busy) = true;"
      # Update indicator based on local OR peer state
      - if:
          condition:
            lambda: 'return id(button_b_state).state || id(peer_b_on);'
          then:
            - switch.turn_on: red_led
          else:
            - switch.turn_off: red_led
      - if:
          condition:
            lambda: 'return !id(button_b_suppress);'
          then:
            - script.execute: b_on_action
            - if:
                condition:
                  lambda: 'return id(mode_b).state == std::string("Coupled") && id(relay_b).state == false;'
                then:
                  - switch.turn_on: relay_b
      - lambda: "id(button_b_busy) = false;"
    on_turn_off:
      - if:
          condition:
            lambda: "return id(button_b_busy);"
          then:
            - switch.toggle: button_b_state
      - lambda: "id(button_b_busy) = true;"
      # Update indicator based on local OR peer state
      - if:
          condition:
            lambda: 'return id(button_b_state).state || id(peer_b_on);'
          then:
            - switch.turn_on: red_led
          else:
            - switch.turn_off: red_led
      - if:
          condition:
            lambda: 'return !id(button_b_suppress);'
          then:
            - script.execute: b_off_action
            - if:
                condition:
                  lambda: 'return id(mode_b).state == std::string("Coupled") && id(relay_b).state == true;'
                then:
                  - switch.turn_off: relay_b
      - lambda: "id(button_b_busy) = false;"

select:
  - platform: template
    id: mode_a
    name: "Button A mode"
    options:
      - "Coupled"
      - "Decoupled"
    optimistic: true
    restore_value: true
    initial_option: ${default_mode_a}
    entity_category: config

  - platform: template
    id: mode_b
    name: "Button B mode"
    options:
      - "Coupled"
      - "Decoupled"
    optimistic: true
    restore_value: true
    initial_option: ${default_mode_b}
    entity_category: config

  - platform: template
    id: relay_a_target_mode
    name: "Relay A target mode"
    options:
      - "On"
      - "Off"
    optimistic: true
    restore_value: true
    initial_option: ${default_relay_a_target_mode}
    entity_category: config
    on_value:
      then:
        - if:
            condition:
              lambda: 'return id(relay_a_target_mode).state == std::string("On");'
            then:
              - switch.turn_on: relay_a
            else:
              - switch.turn_off: relay_a

  - platform: template
    id: relay_b_target_mode
    name: "Relay B target mode"
    options:
      - "On"
      - "Off"
    optimistic: true
    restore_value: true
    initial_option: ${default_relay_b_target_mode}
    entity_category: config
    on_value:
      then:
        - if:
            condition:
              lambda: 'return id(relay_b_target_mode).state == std::string("On");'
            then:
              - switch.turn_on: relay_b
            else:
              - switch.turn_off: relay_b

binary_sensor:
  - platform: gpio
    id: button_a
    pin:
      number: ${button_a_gpio}
      mode: INPUT_PULLUP
      inverted: true
    filters:
      - delayed_on: ${debounce_ms}
      - delayed_off: ${debounce_ms}
    on_press:
      - lambda: "id(a_hold_triggered) = false;"
      - script.execute: a_hold_check
    on_release:
      - if:
          condition:
            lambda: "return !id(a_hold_triggered);"
          then:
            - if:
                condition:
                  lambda: 'return std::string("${role}") == std::string("slave") && std::string("${master_button_a_entity}") != std::string("");'
                then:
                  - homeassistant.service:
                      service: switch.toggle
                      data:
                        entity_id: "${master_button_a_entity}"
                else:
                  - switch.toggle: button_a_state

  - platform: gpio
    id: button_b
    pin:
      number: ${button_b_gpio}
      mode: INPUT_PULLUP
      inverted: true
      ignore_strapping_warning: true
    filters:
      - delayed_on: ${debounce_ms}
      - delayed_off: ${debounce_ms}
    on_press:
      - lambda: "id(b_hold_triggered) = false;"
      - script.execute: b_hold_check
    on_release:
      - if:
          condition:
            lambda: "return !id(b_hold_triggered);"
          then:
            - if:
                condition:
                  lambda: 'return std::string("${role}") == std::string("slave") && std::string("${master_button_b_entity}") != std::string("");'
                then:
                  - homeassistant.service:
                      service: switch.toggle
                      data:
                        entity_id: "${master_button_b_entity}"
                else:
                  - switch.toggle: button_b_state

  # Peer LED sync is provided by an optional package.

  # Mirror the master's A/B states into this device so HA state and LEDs follow master
  - platform: homeassistant
    id: master_a_state_proxy
    entity_id: ${master_button_a_entity}
    internal: true
    on_state:
      then:
        - lambda: 'id(peer_a_on) = id(master_a_state_proxy).state;'
        - if:
            condition:
              lambda: 'return std::string("${role}") == std::string("slave");'
            then:
              - if:
                  condition:
                    lambda: 'return id(master_a_state_proxy).state;'
                  then:
                    - switch.turn_on: button_a_state
                  else:
                    - switch.turn_off: button_a_state

  - platform: homeassistant
    id: master_b_state_proxy
    entity_id: ${master_button_b_entity}
    internal: true
    on_state:
      then:
        - lambda: 'id(peer_b_on) = id(master_b_state_proxy).state;'
        - if:
            condition:
              lambda: 'return std::string("${role}") == std::string("slave");'
            then:
              - if:
                  condition:
                    lambda: 'return id(master_b_state_proxy).state;'
                  then:
                    - switch.turn_on: button_b_state
                  else:
                    - switch.turn_off: button_b_state

script:
  - id: a_hold_blink
    mode: restart
    then:
      - while:
          condition:
            binary_sensor.is_on: button_a
          then:
            # Heartbeat pattern: short pulse, slightly longer pulse, then a pause
            - light.turn_on: blue_led
            - delay: 70ms
            - light.turn_off: blue_led
            - delay: 90ms
            - light.turn_on: blue_led
            - delay: 160ms
            - light.turn_off: blue_led
            - delay: 580ms
      - light.turn_off: blue_led

  - id: a_hold_check
    then:
      - delay: ${hold_start_ms}
      - if:
          condition:
            binary_sensor.is_on: button_a
          then:
            - lambda: "id(a_hold_triggered) = true;"
            - script.execute: a_hold_blink
            - if:
                condition:
                  lambda: 'return std::string("${role}") == std::string("slave") && std::string("${master_button_a_hold_entity}") != std::string("");'
                then:
                  - homeassistant.service:
                      service: button.press
                      data:
                        entity_id: "${master_button_a_hold_entity}"
                else:
                  - button.press: button_a_sim_hold

  - id: a_on_action
    then:
      - if:
          condition:
            lambda: 'return std::string("${button_a_on_service}") != "" && std::string("${button_a_on_entity}") != "";'
          then:
            - homeassistant.service:
                service: "${button_a_on_service}"
                data:
                  entity_id: "${button_a_on_entity}"

  - id: a_off_action
    then:
      - if:
          condition:
            lambda: 'return std::string("${button_a_off_service}") != "" && std::string("${button_a_off_entity}") != "";'
          then:
            - homeassistant.service:
                service: "${button_a_off_service}"
                data:
                  entity_id: "${button_a_off_entity}"

  - id: a_hold_action
    then:
      - if:
          condition:
            lambda: 'return std::string("${button_a_hold_service}") != "" && std::string("${button_a_hold_entity}") != "";'
          then:
            - homeassistant.service:
                service: "${button_a_hold_service}"
                data:
                  entity_id: "${button_a_hold_entity}"

  - id: b_hold_blink
    mode: restart
    then:
      - while:
          condition:
            binary_sensor.is_on: button_b
          then:
            # Heartbeat pattern: same as A
            - light.turn_on: blue_led
            - delay: 70ms
            - light.turn_off: blue_led
            - delay: 90ms
            - light.turn_on: blue_led
            - delay: 160ms
            - light.turn_off: blue_led
            - delay: 580ms
      - light.turn_off: blue_led

  - id: b_hold_check
    then:
      - delay: ${hold_start_ms}
      - if:
          condition:
            binary_sensor.is_on: button_b
          then:
            - lambda: "id(b_hold_triggered) = true;"
            - script.execute: b_hold_blink
            - if:
                condition:
                  lambda: 'return std::string("${role}") == std::string("slave") && std::string("${master_button_b_hold_entity}") != std::string("");'
                then:
                  - homeassistant.service:
                      service: button.press
                      data:
                        entity_id: "${master_button_b_hold_entity}"
                else:
                  - button.press: button_b_sim_hold

  - id: b_on_action
    then:
      - if:
          condition:
            lambda: 'return std::string("${button_b_on_service}") != "" && std::string("${button_b_on_entity}") != "";'
          then:
            - homeassistant.service:
                service: "${button_b_on_service}"
                data:
                  entity_id: "${button_b_on_entity}"

  - id: b_off_action
    then:
      - if:
          condition:
            lambda: 'return std::string("${button_b_off_service}") != "" && std::string("${button_b_off_entity}") != "";'
          then:
            - homeassistant.service:
                service: "${button_b_off_service}"
                data:
                  entity_id: "${button_b_off_entity}"

  - id: b_hold_action
    then:
      - if:
          condition:
            lambda: 'return std::string("${button_b_hold_service}") != "" && std::string("${button_b_hold_entity}") != "";'
          then:
            - homeassistant.service:
                service: "${button_b_hold_service}"
                data:
                  entity_id: "${button_b_hold_entity}"
