substitutions:
  device_model: "Switchman M5 (1-Gang)"
  device_make: "Sonoff"
  package_version: "3.1.3"

  # Safe default for HA entity to follow (uses slug/underscores)
  a_follow_entity: "switch.${device_slug}_relay_a"

  # Blue backlight brightness when it's supposed to be ON (0–100)
  backlight_brightness_pct: "70"

  # Which LED reflects the effective output by default
  indicator_led_default: "Red"        # Blue | Red | None

  # Mode default
  default_mode_a: "Smart + Relay"     # Relay only | Smart only | Smart + Relay

  log_level: INFO
  timezone: "Europe/Tallinn"

esphome:
  name: ${device_name}
  friendly_name: ${device_friendly_name}
  comment: "${device_model} by ${device_make} version ${package_version}"
  on_boot:
    priority: -100
    then:
      # Force both LEDs fully OFF at boot to avoid residual glow
      - output.set_level:
          id: panel_pwm
          level: 1.0      # 1.0 => pin HIGH => blue off on active-low hardware
      - output.turn_off: red_led_out
      # Ensure power stays fed in Smart only (decoupled) mode
      - if:
          condition:
            and:
              - api.connected
              - lambda: 'return id(mode_a).state == "Smart only";'
          then:
            - switch.turn_on: relay_a
      - script.execute: refresh_output

logger:
  level: "${log_level}"
  baud_rate: 0

time:
  - platform: sntp
    id: time_service
    timezone: ${timezone}

esp32:
  board: esp32dev
  framework:
    type: arduino

wifi:
  ssid: ${wifi_ssid}
  password: ${wifi_password}
  ap:
    ssid: "${device_friendly_name} Fallback"
    password: ${ap_password}

api:
  encryption:
    key: ${api_key}
  reboot_timeout: 0s

ota:
  - platform: esphome
    password: ${ota_password}

captive_portal:

web_server:
  port: 80

# We drive LEDs with raw outputs (no light entities to avoid restore/transition quirks).
output:
  # Blue backlight (active-low on M5). Do NOT invert; we compute levels explicitly.
  - platform: ledc
    id: panel_pwm
    pin: GPIO18
    frequency: 1000 Hz

  # Red LED (active-high digital)
  - platform: gpio
    id: red_led_out
    pin: GPIO19

switch:
  # Physical relay
  - platform: gpio
    id: relay_a
    name: "Relay A"
    pin: GPIO23
    on_turn_on:
      then:
        - script.execute: refresh_output
        - if:
            condition:
              lambda: 'return id(mode_a).state != "Smart only";'
            then:
              - if:
                  condition:
                    lambda: 'return id(behavior_a).state == "Momentary 200ms";'
                  then:
                    - delay: 200ms
                    - switch.turn_off: relay_a
              - if:
                  condition:
                    lambda: 'return id(behavior_a).state == "Inching";'
                  then:
                    - delay: !lambda 'return (uint32_t)(id(inching_a_secs).state * 1000);'
                    - switch.turn_off: relay_a
    on_turn_off:
      then:
        - script.execute: refresh_output

  # Effective output exposed to HA
  - platform: template
    id: a_output
    name: "Switch Button A state"
    icon: mdi:light-switch
    lambda: |-
      bool ha_on = (id(a_state).has_state() && id(a_state).state == "on");
      bool rel_on = id(relay_a).state;
      std::string m = id(mode_a).state;
      if (m == "Relay only") return rel_on;
      if (m == "Smart only") return id(a_output_state);
      return (ha_on || rel_on);
    turn_on_action:
      - script.execute: a_do_on
      - script.execute: refresh_output
    turn_off_action:
      - script.execute: a_do_off
      - script.execute: refresh_output

select:
  - platform: template
    id: mode_a
    name: "Mode A"
    options:
      - Relay only
      - Smart only
      - Smart + Relay
    optimistic: true
    restore_value: true
    initial_option: ${default_mode_a}
    entity_category: config

  - platform: template
    id: behavior_a
    name: "Relay A behavior"
    options:
      - Latching
      - Momentary 200ms
      - Inching
    optimistic: true
    restore_value: true
    initial_option: "Latching"
    entity_category: config

  # Which LED reflects the effective output
  - platform: template
    id: indicator_led
    name: "Indicator LED"
    options:
      - Blue
      - Red
      - None
    optimistic: true
    restore_value: true
    initial_option: ${indicator_led_default}
    entity_category: config

number:
  - platform: template
    id: inching_a_secs
    name: "Inching A (s)"
    min_value: 1
    max_value: 600
    step: 1
    initial_value: 5
    optimistic: true
    restore_value: true
    entity_category: config

binary_sensor:
  # Physical button
  - platform: gpio
    id: btn_a
    pin:
      number: GPIO0
      mode: INPUT_PULLUP
      inverted: true
    internal: true
    filters:
      - delayed_on_off: 30ms
    on_click:
      - min_length: 50ms
        max_length: 400ms
        then:
          - script.execute: a_single
    on_double_click:
      - min_length: 50ms
        max_length: 350ms
        then:
          - script.execute: a_double
    on_press:
      then:
        - delay: 500ms
        - if:
            condition:
              binary_sensor.is_on: btn_a
            then:
              - script.execute: a_hold_loop
    on_release:
      then:
        - script.stop: a_hold_loop

  - platform: status
    name: "Status"

sensor:
  - platform: wifi_signal
    name: "WiFi RSSI"
    update_interval: 60s

  - platform: uptime
    name: "Uptime"
    update_interval: 60s

text_sensor:
  # Follow HA entity (safe slug)
  - platform: homeassistant
    id: a_state
    internal: true
    entity_id: ${a_follow_entity}
    on_value:
      then:
        - if:
            condition:
              lambda: 'return id(mode_a).state == "Smart only";'
            then:
              - lambda: |-
                  id(a_output_state) = (id(a_state).state == "on");
        - script.execute: refresh_output

  - platform: version
    name: "ESPHome Version"

  - platform: wifi_info
    ip_address:
      name: "IP"
    ssid:
      name: "SSID"
    bssid:
      name: "BSSID"
    mac_address:
      name: "MAC"

globals:
  - id: a_last_known_on
    type: bool
    restore_value: no
    initial_value: 'false'

  # Optimistic state used in Smart only (decoupled) mode
  - id: a_output_state
    type: bool
    restore_value: no
    initial_value: 'false'

button:
  - platform: template
    name: "Simulate Double Click"
    on_press:
      - script.execute: a_double

  - platform: template
    name: "Simulate Hold (1.5s)"
    on_press:
      - script.execute: a_hold_burst

  - platform: restart
    name: "Restart"

script:
  # Publish effective output & drive LEDs
  - id: refresh_output
    then:
      - lambda: |-
          bool ha_on = (id(a_state).has_state() && id(a_state).state == "on");
          bool rel_on = id(relay_a).state;
          std::string m = id(mode_a).state;
          bool eff = false;
          if (m == "Relay only") eff = rel_on;
          else if (m == "Smart only") eff = id(a_output_state);
          else eff = (ha_on || rel_on);
          id(a_output).publish_state(eff);

      # Blue LED control via raw PWM; Red via digital output.
      # OFF is enforced as: panel_pwm level = 1.0 (pin HIGH on active-low => dark), red off.
      - if:
          condition:
            lambda: 'return id(indicator_led).state == std::string("Blue");'
          then:
            - if:
                condition:
                  lambda: 'return id(a_output).state;'
                then:
                  # Blue ON at requested brightness (active-low => 1.0 - pct)
                  - output.set_level:
                      id: panel_pwm
                      level: !lambda 'return 1.0f - (${backlight_brightness_pct} / 100.0f);'
                  - output.turn_off: red_led_out
                else:
                  - output.set_level:
                      id: panel_pwm
                      level: 1.0
                  - output.turn_off: red_led_out
          else:
            - if:
                condition:
                  lambda: 'return id(indicator_led).state == std::string("Red");'
                then:
                  - if:
                      condition:
                        lambda: 'return id(a_output).state;'
                      then:
                        - output.set_level:
                            id: panel_pwm
                            level: 1.0
                        - output.turn_on: red_led_out
                      else:
                        - output.set_level:
                            id: panel_pwm
                            level: 1.0
                        - output.turn_off: red_led_out
                else:
                  # None selected → both OFF, enforce dark
                  - output.set_level:
                      id: panel_pwm
                      level: 1.0
                  - output.turn_off: red_led_out

  # Single press
  - id: a_single
    then:
      - if:
          condition: api.connected
          then:
            - lambda: |-
                bool ha_on = (id(a_state).has_state() && id(a_state).state == "on");
                bool rel_on = id(relay_a).state;
                std::string m = id(mode_a).state;
                bool eff = false;
                if (m == "Relay only") eff = rel_on;
                else if (m == "Smart only") eff = id(a_output_state);
                else eff = (ha_on || rel_on);
                id(a_last_known_on) = !eff;
            # OFF path
            - if:
                condition:
                  lambda: 'return !id(a_last_known_on);'
                then:
                  - if:
                      condition:
                        lambda: 'return id(mode_a).state != "Smart only";'
                      then:
                        - switch.turn_off: relay_a
                  - if:
                      condition:
                        lambda: 'return strlen("${a_off_entity}") > 0;'
                      then:
                        - homeassistant.service:
                            service: ${a_off_service}
                            data:
                              entity_id: ${a_off_entity}
                  - if:
                      condition:
                        lambda: 'return id(mode_a).state == "Smart only";'
                      then:
                        - lambda: 'id(a_output_state) = false;'
            # ON path
            - if:
                condition:
                  lambda: 'return id(a_last_known_on);'
                then:
                  - if:
                      condition:
                        lambda: 'return id(mode_a).state != "Smart only";'
                      then:
                        - switch.turn_on: relay_a
                  - if:
                      condition:
                        lambda: 'return strlen("${a_on_entity}") > 0;'
                      then:
                        - if:
                            condition:
                              lambda: 'return ${a_on_kelvin} != 0 && ${a_on_brightness_pct} != 0;'
                            then:
                              - homeassistant.service:
                                  service: ${a_on_service}
                                  data:
                                    entity_id: ${a_on_entity}
                                    kelvin: !lambda 'return ${a_on_kelvin};'
                                    brightness_pct: !lambda 'return ${a_on_brightness_pct};'
                        - if:
                            condition:
                              lambda: 'return ${a_on_kelvin} != 0 && ${a_on_brightness_pct} == 0;'
                            then:
                              - homeassistant.service:
                                  service: ${a_on_service}
                                  data:
                                    entity_id: ${a_on_entity}
                                    kelvin: !lambda 'return ${a_on_kelvin};'
                        - if:
                            condition:
                              lambda: 'return ${a_on_kelvin} == 0 && ${a_on_brightness_pct} != 0;'
                            then:
                              - homeassistant.service:
                                  service: ${a_on_service}
                                  data:
                                    entity_id: ${a_on_entity}
                                    brightness_pct: !lambda 'return ${a_on_brightness_pct};'
                        - if:
                            condition:
                              lambda: 'return ${a_on_kelvin} == 0 && ${a_on_brightness_pct} == 0;'
                            then:
                              - homeassistant.service:
                                  service: ${a_on_service}
                                  data:
                                    entity_id: ${a_on_entity}
                  - if:
                      condition:
                        lambda: 'return id(mode_a).state == "Smart only";'
                      then:
                        - lambda: 'id(a_output_state) = true;'
            - script.execute: refresh_output
          else:
            # OFFLINE behavior:
            # - Smart only: toggle virtual state only (never touch relay)
            # - Others: fall back to local relay control
            - if:
                condition:
                  lambda: 'return id(mode_a).state == "Smart only";'
                then:
                  - lambda: 'id(a_output_state) = !id(a_output_state);'
                else:
                  - switch.toggle: relay_a
            - script.execute: refresh_output

  # Double click
  - id: a_double
    then:
      - if:
          condition: api.connected
          then:
            - if:
                condition:
                  lambda: 'return strlen("${a_double_entity}") > 0;'
                then:
                  - if:
                      condition:
                        lambda: 'return ${a_double_step_pct} != 0;'
                      then:
                        - homeassistant.service:
                            service: ${a_double_service}
                            data:
                              entity_id: ${a_double_entity}
                              brightness_step_pct: !lambda 'return ${a_double_step_pct};'
                      else:
                        - homeassistant.service:
                            service: ${a_double_service}
                            data:
                              entity_id: ${a_double_entity}
            - if:
                condition:
                  lambda: 'return strlen("${a_double_entity2}") > 0;'
                then:
                  - homeassistant.service:
                      service: ${a_double_service2}
                      data:
                        entity_id: ${a_double_entity2}
            - if:
                condition:
                  lambda: 'return strlen("${a_double_entity3}") > 0;'
                then:
                  - homeassistant.service:
                      service: ${a_double_service3}
                      data:
                        entity_id: ${a_double_entity3}
          else:
            - if:
                condition:
                  lambda: 'return id(mode_a).state != "Smart only";'
                then:
                  - switch.toggle: relay_a
      - script.execute: refresh_output

  # Hold primitives (no relay touches here)
  - id: a_hold_tick
    then:
      - if:
          condition: api.connected
          then:
            - if:
                condition:
                  lambda: 'return strlen("${a_hold_entity}") > 0;'
                then:
                  - if:
                      condition:
                        lambda: 'return ${a_hold_step_pct} != 0;'
                      then:
                        - homeassistant.service:
                            service: ${a_hold_service}
                            data:
                              entity_id: ${a_hold_entity}
                              brightness_step_pct: !lambda 'return ${a_hold_step_pct};'
                      else:
                        - homeassistant.service:
                            service: ${a_hold_service}
                            data:
                              entity_id: ${a_hold_entity}
            - if:
                condition:
                  lambda: 'return strlen("${a_hold_entity2}") > 0;'
                then:
                  - homeassistant.service:
                      service: ${a_hold_service2}
                      data:
                        entity_id: ${a_hold_entity2}
            - if:
                condition:
                  lambda: 'return strlen("${a_hold_entity3}") > 0;'
                then:
                  - homeassistant.service:
                      service: ${a_hold_service3}
                      data:
                        entity_id: ${a_hold_entity3}
      - script.execute: refresh_output

  - id: a_hold_loop
    then:
      - while:
          condition:
            and:
              - binary_sensor.is_on: btn_a
              - api.connected
          then:
            - script.execute: a_hold_tick
            - delay: 150ms

  - id: a_hold_burst
    then:
      - repeat:
          count: 10
          then:
            - script.execute: a_hold_tick
            - delay: 150ms

  # Direct actions used by the Output switch
  - id: a_do_off
    then:
      - if:
          condition:
            lambda: 'return id(mode_a).state != "Smart only";'
          then:
            - switch.turn_off: relay_a
      - if:
          condition:
            lambda: 'return strlen("${a_off_entity}") > 0;'
          then:
            - homeassistant.service:
                service: ${a_off_service}
                data:
                  entity_id: ${a_off_entity}
      - if:
          condition:
            lambda: 'return id(mode_a).state == "Smart only";'
          then:
            - lambda: 'id(a_output_state) = false;'
      - script.execute: refresh_output

  - id: a_do_on
    then:
      - if:
          condition:
            lambda: 'return id(mode_a).state != "Smart only";'
          then:
            - switch.turn_on: relay_a
      - if:
          condition:
            lambda: 'return strlen("${a_on_entity}") > 0;'
          then:
            - if:
                condition:
                  lambda: 'return ${a_on_kelvin} != 0 && ${a_on_brightness_pct} != 0;'
                then:
                  - homeassistant.service:
                      service: ${a_on_service}
                      data:
                        entity_id: ${a_on_entity}
                        kelvin: !lambda 'return ${a_on_kelvin};'
                        brightness_pct: !lambda 'return ${a_on_brightness_pct};'
            - if:
                condition:
                  lambda: 'return ${a_on_kelvin} != 0 && ${a_on_brightness_pct} == 0;'
                then:
                  - homeassistant.service:
                      service: ${a_on_service}
                      data:
                        entity_id: ${a_on_entity}
                        kelvin: !lambda 'return ${a_on_kelvin};'
            - if:
                condition:
                  lambda: 'return ${a_on_kelvin} == 0 && ${a_on_brightness_pct} != 0;'
                then:
                  - homeassistant.service:
                      service: ${a_on_service}
                      data:
                        entity_id: ${a_on_entity}
                        brightness_pct: !lambda 'return ${a_on_brightness_pct};'
            - if:
                condition:
                  lambda: 'return ${a_on_kelvin} == 0 && ${a_on_brightness_pct} == 0;'
                then:
                  - homeassistant.service:
                      service: ${a_on_service}
                      data:
                        entity_id: ${a_on_entity}
      - if:
          condition:
            lambda: 'return id(mode_a).state == "Smart only";'
          then:
            - lambda: 'id(a_output_state) = true;'
      - script.execute: refresh_output
