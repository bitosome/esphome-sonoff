# Generic package for Sonoff SwitchMan M5 (1-gang, EU)
# Modes (renamed):
#   - Relay only       → control/reflect relay only
#   - Smart only       → call HA services only (keep relay powered when online)
#   - Smart + Relay    → do both; indicators reflect OR(HA, relay)
#
# Gestures: single (toggle), double (fan-out), hold (loop)
# Offline behavior: relay-only; online resumes configured behavior
# Diagnostics: WiFi RSSI, Uptime, ESPHome Version, IP/SSID/BSSID/MAC, Status
#
# NOTE: Define wifi:/api:/ota: in your per-device file. This package assumes api: is present.

substitutions:
  device_name: ""
  device_friendly_name: ""

  # Entity to FOLLOW for state & indicator (defaults to our own relay)
  a_follow_entity: "switch.${device_name}_relay_a"

  # Single-press ON path (used when effective state is currently OFF)
  a_on_service: "switch.turn_on"       # e.g. "light.turn_on"
  a_on_entity: ""                      # e.g. "light.room_main"
  a_on_kelvin: "0"                     # optional; "0" = not sent
  a_on_brightness_pct: "0"             # optional; "0" = not sent

  # Single-press OFF path (used when effective state is currently ON)
  a_off_service: "switch.turn_off"     # e.g. "light.turn_off"
  a_off_entity: ""

  # Double-click fan-out (up to 3 service calls; optional)
  a_double_service: ""
  a_double_entity: ""
  a_double_service2: ""
  a_double_entity2: ""
  a_double_service3: ""
  a_double_entity3: ""
  a_double_step_pct: "0"               # for light.turn_on; "0" = not sent

  # Hold (repeats ~150ms while pressed & online; up to 3 calls; optional)
  a_hold_service: ""
  a_hold_entity: ""
  a_hold_service2: ""
  a_hold_entity2: ""
  a_hold_service3: ""
  a_hold_entity3: ""
  a_hold_step_pct: "0"                 # for light.turn_on; "0" = not sent

  # Default operating mode (new names)
  default_mode_a: "Relay only"         # Relay only | Smart only | Smart + Relay

logger:

# ---- Hardware mapping (Sonoff M5 1-gang EU) ----
# Button A: GPIO0
# Relay A:  GPIO23
# Panel backlight PWM: GPIO18
# Status LED: GPIO5
status_led:
  pin: GPIO5

output:
  - platform: ledc
    id: panel_pwm
    pin: GPIO18
    frequency: 1000 Hz

light:
  - platform: monochromatic
    id: panel_backlight
    name: "${device_friendly_name} Panel Backlight"
    output: panel_pwm
    restore_mode: RESTORE_DEFAULT_OFF
    default_transition_length: 0s

# --- Switches ---
switch:
  # Physical relay
  - platform: gpio
    id: relay_a
    name: "${device_friendly_name} Relay A"
    pin: GPIO23
    on_turn_off:
      then:
        # refresh effective state + indicator
        - binary_sensor.template.publish:
            id: a_effective_state
            state: !lambda |-
              bool ha_on = (id(a_state).has_state() && id(a_state).state == "on");
              bool rel_on = id(relay_a).state;
              std::string m = id(mode_a).state;
              if (m == "Relay only") return rel_on;
              if (m == "Smart only") return ha_on;
              return (ha_on || rel_on);  // Smart + Relay
        - script.execute: update_indicator
        # keep bulbs powered only in Smart only mode while HA is online
        - if:
            condition:
              and:
                - lambda: 'return id(mode_a).state == "Smart only";'
                - api.connected
            then:
              - switch.turn_on: relay_a
    on_turn_on:
      then:
        - binary_sensor.template.publish:
            id: a_effective_state
            state: !lambda |-
              bool ha_on = (id(a_state).has_state() && id(a_state).state == "on");
              bool rel_on = id(relay_a).state;
              std::string m = id(mode_a).state;
              if (m == "Relay only") return rel_on;
              if (m == "Smart only") return ha_on;
              return (ha_on || rel_on);
        - script.execute: update_indicator
        # Apply behavior shaping only when relay participation is allowed
        - if:
            condition:
              lambda: 'return id(mode_a).state != "Smart only";'
            then:
              - if:
                  condition:
                    lambda: 'return id(behavior_a).state == "Momentary 200ms";'
                  then:
                    - delay: 200ms
                    - switch.turn_off: relay_a
              - if:
                  condition:
                    lambda: 'return id(behavior_a).state == "Inching";'
                  then:
                    - delay: !lambda 'return (uint32_t)(id(inching_a_secs).state * 1000);'
                    - switch.turn_off: relay_a

  # Virtual Output (control this from HA; respects Mode A)
  - platform: template
    id: a_virtual_output
    name: "${device_friendly_name} Output"
    icon: "mdi:light-switch"
    lambda: |-
      bool ha_on = (id(a_state).has_state() && id(a_state).state == "on");
      bool rel_on = id(relay_a).state;
      std::string m = id(mode_a).state;
      if (m == "Relay only") return rel_on;
      if (m == "Smart only") return ha_on;
      return (ha_on || rel_on);  // Smart + Relay
    turn_on_action:
      - script.execute: a_do_on
    turn_off_action:
      - script.execute: a_do_off

# --- User-configurable selects/numbers visible in HA ---
select:
  - platform: template
    id: mode_a
    name: "${device_friendly_name} – Mode A"
    options:
      - Relay only
      - Smart only
      - Smart + Relay
    optimistic: true
    restore_value: true
    initial_option: ${default_mode_a}
    entity_category: config

  - platform: template
    id: behavior_a
    name: "${device_friendly_name} – Relay A behavior"
    options:
      - Latching
      - Momentary 200ms
      - Inching
    optimistic: true
    restore_value: true
    initial_option: "Latching"
    entity_category: config

number:
  - platform: template
    id: inching_a_secs
    name: "${device_friendly_name} – Inching A (s)"
    min_value: 1
    max_value: 600
    step: 1
    initial_value: 5
    optimistic: true
    restore_value: true
    entity_category: config

esphome:
  on_boot:
    priority: -100
    then:
      - if:
          condition:
            and:
              - api.connected
              - lambda: 'return id(mode_a).state == "Smart only";'
          then:
            - switch.turn_on: relay_a
      - script.execute: update_indicator

binary_sensor:
  # Physical button
  - platform: gpio
    id: btn_a
    pin:
      number: GPIO0
      mode: INPUT_PULLUP
      inverted: true
    internal: true
    filters:
      - delayed_on_off: 30ms
    # Single click
    on_click:
      - min_length: 50ms
        max_length: 400ms
        then:
          - script.execute: a_single
    # Double click
    on_double_click:
      - min_length: 50ms
        max_length: 350ms
        then:
          - script.execute: a_double
    # Hold: start loop after 500ms; stop when released
    on_press:
      then:
        - delay: 500ms
        - if:
            condition:
              binary_sensor.is_on: btn_a
            then:
              - script.execute: a_hold_loop
    on_release:
      then:
        - script.stop: a_hold_loop

  # Dashboard-friendly state: ON when the *effective output* is ON per mode
  - platform: template
    id: a_effective_state
    name: "${device_friendly_name} Button A state"
    device_class: power
    lambda: |-
      bool ha_on = (id(a_state).has_state() && id(a_state).state == "on");
      bool rel_on = id(relay_a).state;
      std::string m = id(mode_a).state;
      if (m == "Relay only") return rel_on;
      if (m == "Smart only") return ha_on;
      return (ha_on || rel_on);

  # Online status
  - platform: status
    name: "${device_friendly_name} Status"

# Sensors / Diagnostics
sensor:
  - platform: wifi_signal
    name: "${device_friendly_name} WiFi RSSI"
    update_interval: 60s

  - platform: uptime
    name: "${device_friendly_name} Uptime"
    update_interval: 60s

text_sensor:
  # Follow HA entity for state & indicator
  - platform: homeassistant
    id: a_state
    internal: true
    entity_id: ${a_follow_entity}
    on_value:
      then:
        - lambda: |-
            if (id(a_state).state == "on") {
              id(a_last_known_on) = true;
            } else if (id(a_state).state == "off") {
              id(a_last_known_on) = false;
            }
        - binary_sensor.template.publish:
            id: a_effective_state
            state: !lambda |-
              bool ha_on = (id(a_state).has_state() && id(a_state).state == "on");
              bool rel_on = id(relay_a).state;
              std::string m = id(mode_a).state;
              if (m == "Relay only") return rel_on;
              if (m == "Smart only") return ha_on;
              return (ha_on || rel_on);
        - script.execute: update_indicator

  - platform: version
    name: "${device_friendly_name} ESPHome Version"

  - platform: wifi_info
    ip_address:
      name: "${device_friendly_name} IP"
    ssid:
      name: "${device_friendly_name} SSID"
    bssid:
      name: "${device_friendly_name} BSSID"
    mac_address:
      name: "${device_friendly_name} MAC"

globals:
  - id: a_last_known_on
    type: bool
    restore_value: no
    initial_value: 'false'

button:
  # Trigger the same logic as a physical double click (no physical press needed)
  - platform: template
    name: "${device_friendly_name} Simulate Double Click"
    on_press:
      - script.execute: a_double

  # Trigger a short "hold burst" (~1.5s) without physical press
  - platform: template
    name: "${device_friendly_name} Simulate Hold (1.5s)"
    on_press:
      - script.execute: a_hold_burst

  # Utility
  - platform: restart
    name: "${device_friendly_name} Restart"

script:
  # Indicator: backlight reflects effective state per mode
  - id: update_indicator
    then:
      - lambda: |-
          bool ha_on = (id(a_state).has_state() && id(a_state).state == "on");
          bool rel_on = id(relay_a).state;
          std::string m = id(mode_a).state;
          bool on = false;
          if (m == "Relay only") on = rel_on;
          else if (m == "Smart only") on = ha_on;
          else on = (ha_on || rel_on);  // Smart + Relay
          if (on) {
            auto call = id(panel_backlight).turn_on();
            call.set_brightness(0.70f);
            call.perform();
          } else {
            id(panel_backlight).turn_off();
          }

  # --- Single press: toggles effective state; offline = relay toggle only ---
  - id: a_single
    then:
      - if:
          condition:
            api.connected
          then:
            # decide effective current state per mode
            - lambda: |-
                bool ha_on = (id(a_state).has_state() && id(a_state).state == "on");
                bool rel_on = id(relay_a).state;
                std::string m = id(mode_a).state;
                bool eff = false;
                if (m == "Relay only") eff = rel_on;
                else if (m == "Smart only") eff = ha_on;
                else eff = (ha_on || rel_on);
                id(a_last_known_on) = !eff;  // target after press
            # OFF path
            - if:
                condition:
                  lambda: 'return !id(a_last_known_on);'
                then:
                  - if:
                      condition:
                        lambda: 'return id(mode_a).state != "Smart only";'
                      then:
                        - switch.turn_off: relay_a
                  - if:
                      condition:
                        lambda: 'return strlen("${a_off_entity}") > 0;'
                      then:
                        - homeassistant.service:
                            service: ${a_off_service}
                            data:
                              entity_id: ${a_off_entity}
            # ON path
            - if:
                condition:
                  lambda: 'return id(a_last_known_on);'
                then:
                  - if:
                      condition:
                        lambda: 'return id(mode_a).state != "Smart only";'
                      then:
                        - switch.turn_on: relay_a
                  - if:
                      condition:
                        lambda: 'return strlen("${a_on_entity}") > 0;'
                      then:
                        - if:
                            condition:
                              lambda: 'return ${a_on_kelvin} != 0 && ${a_on_brightness_pct} != 0;'
                            then:
                              - homeassistant.service:
                                  service: ${a_on_service}
                                  data:
                                    entity_id: ${a_on_entity}
                                    kelvin: !lambda 'return ${a_on_kelvin};'
                                    brightness_pct: !lambda 'return ${a_on_brightness_pct};'
                        - if:
                            condition:
                              lambda: 'return ${a_on_kelvin} != 0 && ${a_on_brightness_pct} == 0;'
                            then:
                              - homeassistant.service:
                                  service: ${a_on_service}
                                  data:
                                    entity_id: ${a_on_entity}
                                    kelvin: !lambda 'return ${a_on_kelvin};'
                        - if:
                            condition:
                              lambda: 'return ${a_on_kelvin} == 0 && ${a_on_brightness_pct} != 0;'
                            then:
                              - homeassistant.service:
                                  service: ${a_on_service}
                                  data:
                                    entity_id: ${a_on_entity}
                                    brightness_pct: !lambda 'return ${a_on_brightness_pct};'
                        - if:
                            condition:
                              lambda: 'return ${a_on_kelvin} == 0 && ${a_on_brightness_pct} == 0;'
                            then:
                              - homeassistant.service:
                                  service: ${a_on_service}
                                  data:
                                    entity_id: ${a_on_entity}
            # refresh effective state + indicator
            - binary_sensor.template.publish:
                id: a_effective_state
                state: !lambda |-
                  bool ha_on = (id(a_state).has_state() && id(a_state).state == "on");
                  bool rel_on = id(relay_a).state;
                  std::string m = id(mode_a).state;
                  if (m == "Relay only") return rel_on;
                  if (m == "Smart only") return ha_on;
                  return (ha_on || rel_on);
            - script.execute: update_indicator
          else:
            # Offline: act as a dumb switch
            - switch.toggle: relay_a
            - binary_sensor.template.publish:
                id: a_effective_state
                state: !lambda 'return id(relay_a).state;'
            - script.execute: update_indicator

  # --- Double click: up to 3 HA service calls; refresh state/indicator afterwards ---
  - id: a_double
    then:
      - if:
          condition:
            api.connected
          then:
            - if:
                condition:
                  lambda: 'return strlen("${a_double_entity}") > 0;'
                then:
                  - if:
                      condition:
                        lambda: 'return ${a_double_step_pct} != 0;'
                      then:
                        - homeassistant.service:
                            service: ${a_double_service}
                            data:
                              entity_id: ${a_double_entity}
                              brightness_step_pct: !lambda 'return ${a_double_step_pct};'
                      else:
                        - homeassistant.service:
                            service: ${a_double_service}
                            data:
                              entity_id: ${a_double_entity}
            - if:
                condition:
                  lambda: 'return strlen("${a_double_entity2}") > 0;'
                then:
                  - homeassistant.service:
                      service: ${a_double_service2}
                      data:
                        entity_id: ${a_double_entity2}
            - if:
                condition:
                  lambda: 'return strlen("${a_double_entity3}") > 0;'
                then:
                  - homeassistant.service:
                      service: ${a_double_service3}
                      data:
                        entity_id: ${a_double_entity3}
            # refresh effective state + indicator
            - binary_sensor.template.publish:
                id: a_effective_state
                state: !lambda |-
                  bool ha_on = (id(a_state).has_state() && id(a_state).state == "on");
                  bool rel_on = id(relay_a).state;
                  std::string m = id(mode_a).state;
                  if (m == "Relay only") return rel_on;
                  if (m == "Smart only") return ha_on;
                  return (ha_on || rel_on);
            - script.execute: update_indicator
          else:
            - switch.toggle: relay_a
            - binary_sensor.template.publish:
                id: a_effective_state
                state: !lambda 'return id(relay_a).state;'
            - script.execute: update_indicator

  # --- One "tick" of hold behavior (used by real holds and HA buttons) ---
  - id: a_hold_tick
    then:
      - if:
          condition:
            api.connected
          then:
            - if:
                condition:
                  lambda: 'return strlen("${a_hold_entity}") > 0;'
                then:
                  - if:
                      condition:
                        lambda: 'return ${a_hold_step_pct} != 0;'
                      then:
                        - homeassistant.service:
                            service: ${a_hold_service}
                            data:
                              entity_id: ${a_hold_entity}
                              brightness_step_pct: !lambda 'return ${a_hold_step_pct};'
                      else:
                        - homeassistant.service:
                            service: ${a_hold_service}
                            data:
                              entity_id: ${a_hold_entity}
            - if:
                condition:
                  lambda: 'return strlen("${a_hold_entity2}") > 0;'
                then:
                  - homeassistant.service:
                      service: ${a_hold_service2}
                      data:
                        entity_id: ${a_hold_entity2}
            - if:
                condition:
                  lambda: 'return strlen("${a_hold_entity3}") > 0;'
                then:
                  - homeassistant.service:
                      service: ${a_hold_service3}
                      data:
                        entity_id: ${a_hold_entity3}
            # refresh effective state + indicator (in case services changed on/off)
            - binary_sensor.template.publish:
                id: a_effective_state
                state: !lambda |-
                  bool ha_on = (id(a_state).has_state() && id(a_state).state == "on");
                  bool rel_on = id(relay_a).state;
                  std::string m = id(mode_a).state;
                  if (m == "Relay only") return rel_on;
                  if (m == "Smart only") return ha_on;
                  return (ha_on || rel_on);
            - script.execute: update_indicator

  # --- Real hold loop (physical press) ---
  - id: a_hold_loop
    then:
      - while:
          condition:
            and:
              - binary_sensor.is_on: btn_a
              - api.connected
          then:
            - script.execute: a_hold_tick
            - delay: 150ms

  # --- HA button to emulate a ~1.5s hold (10 ticks @150ms) ---
  - id: a_hold_burst
    then:
      - repeat:
          count: 10
          then:
            - script.execute: a_hold_tick
            - delay: 150ms

  # --- Explicit actions used by the Virtual Output switch (no HA helpers needed) ---
  - id: a_do_off
    then:
      - if:
          condition:
            lambda: 'return id(mode_a).state != "Smart only";'
          then:
            - switch.turn_off: relay_a
      - if:
          condition:
            lambda: 'return strlen("${a_off_entity}") > 0;'
          then:
            - homeassistant.service:
                service: ${a_off_service}
                data:
                  entity_id: ${a_off_entity}
      - binary_sensor.template.publish:
          id: a_effective_state
          state: !lambda |-
            bool ha_on = (id(a_state).has_state() && id(a_state).state == "on");
            bool rel_on = id(relay_a).state;
            std::string m = id(mode_a).state;
            if (m == "Relay only") return rel_on;
            if (m == "Smart only") return ha_on;
            return (ha_on || rel_on);
      - script.execute: update_indicator

  - id: a_do_on
    then:
      - if:
          condition:
            lambda: 'return id(mode_a).state != "Smart only";'
          then:
            - switch.turn_on: relay_a
      - if:
          condition:
            lambda: 'return strlen("${a_on_entity}") > 0;'
          then:
            - if:
                condition:
                  lambda: 'return ${a_on_kelvin} != 0 && ${a_on_brightness_pct} != 0;'
                then:
                  - homeassistant.service:
                      service: ${a_on_service}
                      data:
                        entity_id: ${a_on_entity}
                        kelvin: !lambda 'return ${a_on_kelvin};'
                        brightness_pct: !lambda 'return ${a_on_brightness_pct};'
            - if:
                condition:
                  lambda: 'return ${a_on_kelvin} != 0 && ${a_on_brightness_pct} == 0;'
                then:
                  - homeassistant.service:
                      service: ${a_on_service}
                      data:
                        entity_id: ${a_on_entity}
                        kelvin: !lambda 'return ${a_on_kelvin};'
            - if:
                condition:
                  lambda: 'return ${a_on_kelvin} == 0 && ${a_on_brightness_pct} != 0;'
                then:
                  - homeassistant.service:
                      service: ${a_on_service}
                      data:
                        entity_id: ${a_on_entity}
                        brightness_pct: !lambda 'return ${a_on_brightness_pct};'
            - if:
                condition:
                  lambda: 'return ${a_on_kelvin} == 0 && ${a_on_brightness_pct} == 0;'
                then:
                  - homeassistant.service:
                      service: ${a_on_service}
                      data:
                        entity_id: ${a_on_entity}
      - binary_sensor.template.publish:
          id: a_effective_state
          state: !lambda |-
            bool ha_on = (id(a_state).has_state() && id(a_state).state == "on");
            bool rel_on = id(relay_a).state;
            std::string m = id(mode_a).state;
            if (m == "Relay only") return rel_on;
            if (m == "Smart only") return ha_on;
            return (ha_on || rel_on);
      - script.execute: update_indicator
