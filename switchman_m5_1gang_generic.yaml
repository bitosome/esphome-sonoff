substitutions:
  device_model: "Switchman M5 (1-Gang)"
  device_make: "Sonoff"
  package_version: "3.8.0"

  log_level: INFO
  timezone: "Europe/Tallinn"

esphome:
  name: ${device_name}
  friendly_name: ${device_friendly_name}
  comment: "${device_model} by ${device_make} v${package_version}"
  on_boot:
    priority: -100
    then:
      - lambda: 'id(cpu_speed) = ESP.getCpuFreqMHz();'
      - light.turn_on: blue          # blink until API connects (turned OFF once connected)
      - switch.turn_off: red     # front red LED dark at boot
      - script.execute: refresh_output

logger:
  level: "${log_level}"
  baud_rate: 0

time:
  - platform: sntp
    id: time_service
    timezone: ${timezone}

esp32:
  board: esp32dev
  framework:
    type: arduino

wifi:
  ssid: ${wifi_ssid}
  password: ${wifi_password}
  ap:
    ssid: "${device_friendly_name} Fallback"
    password: ${ap_password}

api:
  encryption:
    key: ${api_key}
  reboot_timeout: 0s
  on_client_connected:
    then:
      - script.execute: refresh_output
  on_client_disconnected:
    then:
      - script.execute: refresh_output

ota:
  - platform: esphome
    password: ${ota_password}

captive_portal:

web_server:
  port: 80

# ----------------------------------------------------------------
# SCRIPTS (early so all IDs exist before use)
# ----------------------------------------------------------------
script:
  # Compute effective output (LED control happens on switch state callbacks)
  - id: refresh_output
    then:
      - lambda: |-
          bool use_self = std::string("${a_follow_mode}") == "self";
          bool ha_on = use_self ? id(relay_a).state
                                : (id(a_state).has_state() && id(a_state).state == "on");
          bool rel_on = id(relay_a).state;
          std::string m = id(mode_a).state;
          bool eff = false;
          // Decoupled -> virtual smart state only; Coupled -> relay OR followed HA entity
          if (m == "Decoupled") eff = id(a_output_state);
          else                   eff = (ha_on || rel_on);
          id(a_output).publish_state(eff);

  # Single click / toggle
  - id: a_single
    then:
      - if:
          condition: api.connected
          then:
            - lambda: |-
                bool use_self = std::string("${a_follow_mode}") == "self";
                bool ha_on = use_self ? id(relay_a).state
                                      : (id(a_state).has_state() && id(a_state).state == "on");
                bool rel_on = id(relay_a).state;
                std::string m = id(mode_a).state;
                bool eff = false;
                if (m == "Decoupled") eff = id(a_output_state);
                else                   eff = (ha_on || rel_on);
                id(a_last_known_on) = !eff;
            # OFF path
            - if:
                condition:
                  lambda: 'return !id(a_last_known_on);'
                then:
                  - if:
                      condition:
                        lambda: 'return id(mode_a).state != "Decoupled";'
                      then:
                        - switch.turn_off: relay_a
                  - if:
                      condition:
                        lambda: 'return strlen("${a_off_entity}") > 0;'
                      then:
                        - homeassistant.service:
                            service: ${a_off_service}
                            data:
                              entity_id: ${a_off_entity}
                  - if:
                      condition:
                        lambda: 'return id(mode_a).state == "Decoupled";'
                      then:
                        - lambda: 'id(a_output_state) = false;'
            # ON path
            - if:
                condition:
                  lambda: 'return id(a_last_known_on);'
                then:
                  - if:
                      condition:
                        lambda: 'return id(mode_a).state != "Decoupled";'
                      then:
                        - switch.turn_on: relay_a
                  - if:
                      condition:
                        lambda: 'return strlen("${a_on_entity}") > 0;'
                      then:
                        - homeassistant.service:
                            service: ${a_on_service}
                            data:
                              entity_id: ${a_on_entity}
                  - if:
                      condition:
                        lambda: 'return id(mode_a).state == "Decoupled";'
                      then:
                        - lambda: 'id(a_output_state) = true;'

            - text_sensor.template.publish:
                id: a_last_action
                state: "single"
            - script.execute: refresh_output
          else:
            # Offline behavior
            - if:
                condition:
                  lambda: 'return id(mode_a).state == "Decoupled";'
                then:
                  - lambda: 'id(a_output_state) = !id(a_output_state);'
                else:
                  - switch.toggle: relay_a
            - text_sensor.template.publish:
                id: a_last_action
                state: "single"
            - script.execute: refresh_output

  # Double click (single entity)
  - id: a_double
    then:
      - if:
          condition: api.connected
          then:
            - if:
                condition:
                  lambda: 'return strlen("${a_double_entity}") > 0;'
                then:
                  - homeassistant.service:
                      service: ${a_double_service}
                      data:
                        entity_id: ${a_double_entity}
      - text_sensor.template.publish:
          id: a_last_action
          state: "double_click"
      - binary_sensor.template.publish:
          id: a_double_event
          state: ON
      - delay: 250ms
      - binary_sensor.template.publish:
          id: a_double_event
          state: OFF
      - script.execute: refresh_output

  # Hold tick (single entity; repeated while held)
  - id: a_hold_tick
    then:
      - if:
          condition: api.connected
          then:
            - if:
                condition:
                  lambda: 'return strlen("${a_hold_entity}") > 0;'
                then:
                  - homeassistant.service:
                      service: ${a_hold_service}
                      data:
                        entity_id: ${a_hold_entity}
      - script.execute: refresh_output

  # Loop while the button stays pressed
  - id: a_hold_loop
    then:
      - while:
          condition:
            and:
              - binary_sensor.is_on: btn_a
              - api.connected
          then:
            - script.execute: a_hold_tick
            - delay: 150ms

  # Quick burst helper so HA button can "simulate" a hold
  - id: a_hold_burst
    then:
      - text_sensor.template.publish:
          id: a_last_action
          state: "hold"
      - binary_sensor.template.publish:
          id: a_hold_active
          state: ON
      - repeat:
          count: 10
          then:
            - script.execute: a_hold_tick
            - delay: 150ms
      - binary_sensor.template.publish:
          id: a_hold_active
          state: OFF

  # Direct actions used by the Output switch
  - id: a_do_off
    then:
      - if:
          condition:
            lambda: 'return id(mode_a).state != "Decoupled";'
          then:
            - switch.turn_off: relay_a
      - if:
          condition:
            lambda: 'return strlen("${a_off_entity}") > 0;'
          then:
            - homeassistant.service:
                service: ${a_off_service}
                data:
                  entity_id: ${a_off_entity}
      - if:
          condition:
            lambda: 'return id(mode_a).state == "Decoupled";'
          then:
            - lambda: 'id(a_output_state) = false;'
      - script.execute: refresh_output

  - id: a_do_on
    then:
      - if:
          condition:
            lambda: 'return id(mode_a).state != "Decoupled";'
          then:
            - switch.turn_on: relay_a
      - if:
          condition:
            lambda: 'return strlen("${a_on_entity}") > 0;'
          then:
            - homeassistant.service:
                service: ${a_on_service}
                data:
                  entity_id: ${a_on_entity}
      - if:
          condition:
            lambda: 'return id(mode_a).state == "Decoupled";'
          then:
            - lambda: 'id(a_output_state) = true;'
      - script.execute: refresh_output

# -------------------- IO (Sonoff M5 1-gang)
# GPIO00: Button | GPIO23: Relay | GPIO19: Red LED (as a switch) | GPIO05: Blue status LED
light:
  # Blue status LED (blinks when ON). We turn it OFF when connected via template sensor below.
  - platform: status_led
    id: blue
    name: "Blue LED"
    pin:
      number: GPIO5
      inverted: true
      ignore_strapping_warning: true
    internal: true

switch:
  - platform: gpio
    id: red
    name: "Red LED"
    pin: GPIO19
    restore_mode: RESTORE_DEFAULT_OFF

  - platform: gpio
    id: relay_a
    name: "Relay A"
    pin: GPIO23
    restore_mode: RESTORE_DEFAULT_OFF
    on_turn_on:
      then:
        - script.execute: refresh_output
        - if:
            condition:
              lambda: 'return id(mode_a).state != "Decoupled";'
            then:
              - if:
                  condition:
                    lambda: 'return id(behavior_a).state == "Momentary 200ms";'
                  then:
                    - delay: 200ms
                    - switch.turn_off: relay_a
              - if:
                  condition:
                    lambda: 'return id(behavior_a).state == "Inching";'
                  then:
                    - delay: !lambda 'return (uint32_t)(id(inching_a_secs).state * 1000);'
                    - switch.turn_off: relay_a
    on_turn_off:
      then:
        - script.execute: refresh_output

  # Effective output exposed to HA (button/“smart” state)
  - platform: template
    id: a_output
    name: "Button A state"
    icon: mdi:light-switch
    lambda: |-
      bool use_self = std::string("${a_follow_mode}") == "self";
      bool ha_on = use_self ? id(relay_a).state
                            : (id(a_state).has_state() && id(a_state).state == "on");
      bool rel_on = id(relay_a).state;
      std::string m = id(mode_a).state;
      if (m == "Decoupled") return id(a_output_state);
      return (ha_on || rel_on);
    turn_on_action:
      - script.execute: a_do_on
      - script.execute: refresh_output
    turn_off_action:
      - script.execute: a_do_off
      - script.execute: refresh_output
    # Drive LED like before (no HA event emission)
    on_turn_on:
      - switch.turn_on: red
    on_turn_off:
      - switch.turn_off: red

# -------------------- Config selects & numbers
select:
  - platform: template
    id: mode_a
    name: "Mode - Button A"
    options:
      - Coupled
      - Decoupled
    optimistic: true
    restore_value: true
    initial_option: ${default_mode_a}
    entity_category: config

  - platform: template
    id: behavior_a
    name: "Relay A behavior"
    options:
      - Latching
      - Momentary 200ms
      - Inching
    optimistic: true
    restore_value: true
    initial_option: "Latching"
    entity_category: config

number:
  - platform: template
    id: inching_a_secs
    name: "Inching A (s)"
    min_value: 1
    max_value: 600
    step: 1
    initial_value: 5
    optimistic: true
    restore_value: true
    entity_category: config

# -------------------- Inputs & status
binary_sensor:
  - platform: gpio
    id: btn_a
    pin:
      number: GPIO0
      mode: INPUT_PULLUP
      inverted: true
      ignore_strapping_warning: true
    internal: true
    filters:
      - delayed_on_off: 30ms
    on_click:
      - min_length: 50ms
        max_length: 400ms
        then:
          - script.execute: a_single
    on_double_click:
      - min_length: 50ms
        max_length: 350ms
        then:
          - script.execute: a_double
    on_press:
      then:
        - delay: 500ms
        - if:
            condition:
              binary_sensor.is_on: btn_a
            then:
              - text_sensor.template.publish:
                  id: a_last_action
                  state: "hold"
              - binary_sensor.template.publish:
                  id: a_hold_active
                  state: ON
              - script.execute: a_hold_loop
    on_release:
      then:
        - binary_sensor.template.publish:
            id: a_hold_active
            state: OFF
        - script.stop: a_hold_loop

  - platform: status
    name: "API Status"
    id: sensor_status
    disabled_by_default: true
    entity_category: diagnostic

  # EXACTLY like your original:
  # - When API connected -> turn OFF blue LED (no blink)
  # - When API disconnected -> turn ON blue LED (blink)
  - platform: template
    name: "API connected"
    id: sensor_api_connected
    internal: true
    entity_category: diagnostic
    device_class: connectivity
    lambda: return global_api_server->is_connected();
    on_press:
      - light.turn_off: blue
    on_release:
      - light.turn_on: blue

  # Momentary event pulse for visibility in HA when a physical/simulated double click occurs
  - platform: template
    id: a_double_event
    name: "Button A double click event"
    entity_category: diagnostic

  # Shows when a hold is currently active
  - platform: template
    id: a_hold_active
    name: "Button A hold event"
    entity_category: diagnostic

sensor:
  - platform: wifi_signal
    name: "RSSI"
    id: sensor_rssi
    update_interval: 60s
    entity_category: diagnostic

  - platform: uptime
    name: "Uptime (raw seconds)"
    id: sensor_uptime
    update_interval: 60s
    entity_category: diagnostic
    internal: true
    on_raw_value:
      then:
        - text_sensor.template.publish:
            id: uptime_human
            state: !lambda |-
              int seconds = round(id(sensor_uptime).raw_state);
              int days = seconds / (24 * 3600);
              seconds = seconds % (24 * 3600);
              int hours = seconds / 3600;
              seconds = seconds % 3600;
              int minutes = seconds / 60;
              seconds = seconds % 60;
              return (
                (days ? String(days) + "d " : "") +
                (hours ? String(hours) + "h " : "") +
                (minutes ? String(minutes) + "m " : "") +
                (String(seconds) + "s")
              ).c_str();

  - platform: template
    id: esp_memory
    icon: mdi:memory
    name: "Free Memory"
    lambda: return heap_caps_get_free_size(MALLOC_CAP_INTERNAL) / 1024;
    unit_of_measurement: "kB"
    state_class: measurement
    entity_category: diagnostic
    disabled_by_default: true

  - platform: internal_temperature
    name: "Internal Temperature"
    disabled_by_default: true
    icon: mdi:heat-wave
    entity_category: diagnostic

  - platform: template
    name: "CPU Frequency"
    icon: "mdi:speedometer"
    accuracy_decimals: 0
    unit_of_measurement: "MHz"
    disabled_by_default: true
    lambda: |-
      return (id(cpu_speed));
    entity_category: diagnostic

text_sensor:
  - platform: template
    name: "Uptime"
    id: uptime_human
    icon: "mdi:timer-check-outline"
    update_interval: 60s
    entity_category: diagnostic
    disabled_by_default: true

  - platform: template
    name: "Button A last action"
    id: a_last_action
    entity_category: diagnostic

  - platform: version
    name: "ESPHome Version"

  - platform: wifi_info
    ip_address:
      id: ip_address
      name: "IP Address"
      icon: "mdi:wan"
    ssid:
      name: "SSID"
    bssid:
      name: "BSSID"
    mac_address:
      name: "MAC"

  # Only used when a_follow_mode == "ha" (placeholder in mini ensures one dot)
  - platform: homeassistant
    id: a_state
    internal: true
    entity_id: ${a_follow_entity}
    on_value:
      then:
        - if:
            condition:
              lambda: 'return id(mode_a).state == "Decoupled";'
            then:
              - lambda: |-
                  id(a_output_state) = (id(a_state).state == "on");
        - script.execute: refresh_output

globals:
  - id: a_last_known_on
    type: bool
    restore_value: no
    initial_value: 'false'

  - id: a_output_state
    type: bool
    restore_value: no
    initial_value: 'false'

  - id: cpu_speed
    type: int
    restore_value: no
    initial_value: "0"

button:
  # Use these from HA UI/automations to trigger the same logic as a physical double-click/hold
  - platform: template
    name: "Button A double click action"
    id: button_a_double_click_action
    on_press:
      - script.execute: a_double

  - platform: template
    name: "Button A hold action"
    id: button_a_hold_action
    on_press:
      - script.execute: a_hold_burst

  - platform: restart
    name: "Reboot Device"
    id: button_restart
    icon: mdi:power-cycle
    entity_category: diagnostic
