# Generic package for Sonoff SwitchMan M5 (1-gang, EU)
# Same behavior as 2-gang package but only Gang A and with correct pins for 1-gang.

substitutions:
  device_name: ""
  device_friendly_name: ""

  # Follow defaults to our own relay so it compiles even if you don't override.
  a_follow_entity: "switch.${device_name}_relay_a"

  # Single press ON/OFF
  a_on_service: "switch.turn_on"
  a_on_entity: ""
  a_on_kelvin: "0"
  a_on_brightness_pct: "0"
  a_off_service: "switch.turn_off"
  a_off_entity: ""

  # Double (up to 3)
  a_double_service: ""
  a_double_entity: ""
  a_double_service2: ""
  a_double_entity2: ""
  a_double_service3: ""
  a_double_entity3: ""
  a_double_step_pct: "0"

  # Hold (loop; up to 3)
  a_hold_service: ""
  a_hold_entity: ""
  a_hold_service2: ""
  a_hold_entity2: ""
  a_hold_service3: ""
  a_hold_entity3: ""
  a_hold_step_pct: "0"

  default_mode_a: "Local"

logger:

# ----- Hardware mapping (1-gang, EU) -----
# Button A: GPIO00
# Relay A:  GPIO23
# LED1:     GPIO19  (separate from relay on 1-gang)
# Panel PWM (backlight): GPIO18
# Status LED: GPIO5
# Ref: devices.esphome.io Sonoff M5 1/2/3-gang
status_led:
  pin: GPIO5

output:
  - platform: ledc
    id: panel_pwm
    pin: GPIO18
    frequency: 1000 Hz

light:
  - platform: monochromatic
    id: panel_backlight
    name: "${device_friendly_name} Panel Backlight"
    output: panel_pwm
    restore_mode: ALWAYS_ON
    default_transition_length: 0s

switch:
  - platform: gpio
    id: relay_a
    name: "${device_friendly_name} Relay A"
    pin: GPIO23
    on_turn_off:
      then:
        - if:
            condition:
              and:
                - lambda: return id(mode_a).state == "HA only";
                - api.connected
            then:
              - switch.turn_on: relay_a

select:
  - platform: template
    id: mode_a
    name: "${device_friendly_name} â€“ Mode A"
    options: [Local, "HA only", Both]
    optimistic: true
    restore_value: true
    initial_option: ${default_mode_a}

esphome:
  on_boot:
    priority: -100
    then:
      - if:
          condition:
            and:
              - api.connected
              - lambda: return id(mode_a).state == "HA only";
          then:
            - switch.turn_on: relay_a

binary_sensor:
  - platform: gpio
    id: btn_a
    pin: { number: GPIO0, mode: INPUT_PULLUP, inverted: true }
    internal: true
    filters: [ delayed_on_off: 30ms ]
    on_click:
      - min_length: 50ms
        max_length: 400ms
        then: [ script.execute: a_single ]
    on_double_click:
      - min_length: 50ms
        max_length: 350ms
        then: [ script.execute: a_double ]
    on_press:
      then:
        - delay: 500ms
        - if:
            condition: 'return id(btn_a).state;'
            then: [ script.execute: a_hold_loop ]
    on_release:
      then:
        - script.stop: a_hold_loop

text_sensor:
  - platform: homeassistant
    id: a_state
    entity_id: ${a_follow_entity}
    on_value:
      then: [ script.execute: update_indicator ]

globals:
  - id: a_last_known_on
    type: bool
    restore_value: no
    initial_value: 'false'

script:
  - id: update_indicator
    then:
      - lambda: |-
          bool on = (id(a_state).has_state() && id(a_state).state == "on");
          auto call = id(panel_backlight).turn_on();
          call.set_brightness(on ? 0.70f : 0.15f);
          call.perform();

  - id: a_single
    then:
      - if:
          condition:
            lambda: return api_connected;
          then:
            - lambda: |-
                bool is_on = id(a_last_known_on);
                if (!id(a_state).has_state()) { is_on = id(relay_a).state; }
                id(a_last_known_on) = !is_on;
            - if:
                condition:
                  lambda: return !id(a_last_known_on);
                then:
                  - if: { condition: lambda: return id(mode_a).state != "HA only"; then: [ switch.turn_off: relay_a ] }
                  - if:
                      condition: lambda: return strlen("${a_off_entity}")>0;
                      then:
                        - homeassistant.action:
                            action: ${a_off_service}
                            data: { entity_id: ${a_off_entity} }
                else:
                  - if: { condition: lambda: return id(mode_a).state != "HA only"; then: [ switch.turn_on: relay_a ] }
                  - if:
                      condition: lambda: return strlen("${a_on_entity}")>0;
                      then:
                        - homeassistant.action:
                            action: ${a_on_service}
                            data:
                              entity_id: ${a_on_entity}
                              kelvin: !lambda "return ${a_on_kelvin};"
                              brightness_pct: !lambda "return ${a_on_brightness_pct};"
          else:
            - switch.toggle: relay_a

  - id: a_double
    then:
      - if:
          condition: api.connected
          then:
            - if: { condition: lambda: return strlen("${a_double_entity}")>0;  then:
                - homeassistant.action:
                    action: ${a_double_service}
                    data: { entity_id: ${a_double_entity}, brightness_step_pct: !lambda "return ${a_double_step_pct};" } }
            - if: { condition: lambda: return strlen("${a_double_entity2}")>0; then:
                - homeassistant.action:
                    action: ${a_double_service2}
                    data: { entity_id: ${a_double_entity2} } }
            - if: { condition: lambda: return strlen("${a_double_entity3}")>0; then:
                - homeassistant.action:
                    action: ${a_double_service3}
                    data: { entity_id: ${a_double_entity3} } }
          else:
            - switch.toggle: relay_a

  - id: a_hold_loop
    then:
      - while:
          condition: 'return id(btn_a).state && api_connected;'
          then:
            - if: { condition: lambda: return strlen("${a_hold_entity}")>0; then:
                - homeassistant.action:
                    action: ${a_hold_service}
                    data: { entity_id: ${a_hold_entity}, brightness_step_pct: !lambda "return ${a_hold_step_pct};" } }
            - if: { condition: lambda: return strlen("${a_hold_entity2}")>0; then:
                - homeassistant.action:
                    action: ${a_hold_service2}
                    data: { entity_id: ${a_hold_entity2} } }
            - if: { condition: lambda: return strlen("${a_hold_entity3}")>0; then:
                - homeassistant.action:
                    action: ${a_hold_service3}
                    data: { entity_id: ${a_hold_entity3} } }
            - delay: 150ms
